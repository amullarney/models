domain,UDT,User_Defined_Types,,,,,,
object,An_Active_Object,,,,,,,
object,,,,,,,,
object,Final_Test_Data,,,,,,,
object,,,,,,,,
object,Object_Into_Bridge,,,,,,,
object,,,,,,,,
object,Object_With_Enumerators,,,,,,,
object,,,,,,,,
object,Object_With_Integers,,,,,,,
object,,,,,,,,
object,Object_With_Reals,,,,,,,
object,,,,,,,,
object,Report_Data,,,,,,,
object,,,,,,,,
object,Test_Data,,,,,,,
object,,,,,,,,
type,Active_Object_Status_Type,private,,,,,,
enumeration,Active_Object_Status_Type,,,,,,,
enumerator,Enumeral,,,,,,,
enumerator,,,,,,,,
enumerator,Number,,,,,,,
enumerator,,,,,,,,
enumerator,OK,,,,,,,
enumerator,,,,,,,,
enumerator,Not_Tested,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Mminimum_To_Maximum_Of_Real,private,real,,,,,
range,-32768.0,32767.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Minimum_To_Minus_One_Of_Real,private,real,,,,,
range,-32768.0,-1.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,One_To_Maximum_Of_Real,private,real,,,,,
range,1.0,32767.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Subset_Zero_Of_Real,private,real,,,,,
range,-10.0,10.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Subset_Minus_1_Of_Real,private,real,,,,,
range,-10.0,-1.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Subset_1_Of_Real,private,real,,,,,
range,1.0,10.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Minimum_To_Maximum_Integer,private,integer,,,,,
range,-32768,32767,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Minimum_To_Minus_One_Integer,private,integer,,,,,
range,-32768,-1,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Subset_Minus_1_Of_Integer,private,integer,,,,,
range,-10,-1,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Subset_1_Of_Integer,private,integer,,,,,
range,1,10,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Timer_ID,public,integer,,,,,
type,,,,,,,,
type,One_To_Maximum_Integer,public,integer,,,,,
range,1,32767,,,,,,
range,,,,,,,,
description, Insert system defined integer'last%0A,,,,,,,
type,,,,,,,,
type,Subset_Zero_Of_Integer,public,integer,,,,,
range,-10,10,,,,,,
range,,,,,,,,
type,,,,,,,,
type,Temp_Type,public,,,,,,
enumeration,Temp_Type,,,,,,,
enumerator,Freezing,,,,,,,
enumerator,,,,,,,,
enumerator,Cold,,,,,,,
enumerator,,,,,,,,
enumerator,Mild,,,,,,,
enumerator,,,,,,,,
enumerator,Warm,,,,,,,
enumerator,,,,,,,,
enumerator,Hot,,,,,,,
enumerator,,,,,,,,
enumerator,Boiling,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Colour_Type,public,,,,,,
enumeration,Colour_Type,,,,,,,
enumerator,Red,,,,,,,
enumerator,,,,,,,,
enumerator,Green,,,,,,,
enumerator,,,,,,,,
enumerator,Blue,,,,,,,
enumerator,,,,,,,,
enumerator,Yellow,,,,,,,
enumerator,,,,,,,,
enumerator,Cyan,,,,,,,
enumerator,,,,,,,,
enumerator,Magenta,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Simple_Enumeration_Type,public,,,,,,
enumeration,Simple_Enumeration_Type,,,,,,,
enumerator,One,,,,,,,
enumerator,,,,,,,,
enumerator,Two,,,,,,,
enumerator,,,,,,,,
enumerator,Three,,,,,,,
enumerator,,,,,,,,
enumerator,Four,,,,,,,
enumerator,,,,,,,,
enumerator,Five,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Time_Unit,public,,,,,,
enumeration,Time_Unit,,,,,,,
enumerator,MICROSECOND,,,,,,,
enumerator,,,,,,,,
enumerator,MILLISECOND,,,,,,,
enumerator,,,,,,,,
enumerator,SECOND,,,,,,,
enumerator,,,,,,,,
enumerator,MINUTE,,,,,,,
enumerator,,,,,,,,
enumerator,HOUR,,,,,,,
enumerator,,,,,,,,
enumerator,DAY,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
description, Used to define the granularity of Time%0A,,,,,,,
type,,,,,,,,
routine,UDT,,private,Integer_Number_Scenarios,1,,,
codeblock,#--------------------------------------------------------------------------%0A#Call domain based synchronous service%0A#--------------------------------------------------------------------------%0A%0A# Create test data%2C stashed in a specially created object%0ATest = 1%0A%0ANew_Object = TRUE%0AFinal_Object = FALSE%0A%0ADummy_TD = create Test_Data with The_Test_Number = 99 & Testing_For_What = "Nothing"%0A%0AA_Test_Data_IH = Dummy_TD%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C Dummy_TD%2C     Test%2C "Object data assignment"%2C Final_Object]%0A%0A# Don't need this beasty any more%2C it was only ever a dummy.%0Adelete Dummy_TD%0A%0ANew_Object = FALSE%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Max value assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Min value assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Common local assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Unique local assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Unique local assignment"%2C Final_Object]%0A%0AFinal_Object = TRUE%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Min plus max"%2C Final_Object]%0A%0Alocal_counter = 1%0A%0Aif A_Test_Data_IH != UNDEFINED then%0A  %0A   [] = UDT1::Check_The_Integers[local_counter%2C A_Test_Data_IH.Testing_For_What%2C "1241-0000-01-0112"]%0A%0A   loop%0A%0A      breakif local_counter = Test%0A      local_counter = local_counter + 1%0A %0A      A_Test_Data_IH = A_Test_Data_IH -> R1."Has_a".Test_Data   %0A%0A      if A_Test_Data_IH != UNDEFINED then%0A%0A         if local_counter = 7 then%0A            [] = UDT1::Check_The_Integers[local_counter%2C A_Test_Data_IH.Testing_For_What%2C "Null Requid"]%0A         else%0A            [] = UDT1::Check_The_Integers[local_counter%2C A_Test_Data_IH.Testing_For_What%2C "1241-0000-01-0112"]%0A         endif%0A%0A      else%0A         # Oops%0A         break%0A      endif%0A%0A   endloop%0A%0Aelse%0A   [] = RPT5:Test_Text[local_counter%2C "First Test Data object corrupt"]%0Aendif%0A%0A# Tidy up the test data objects starting at the final one%0A%0A[] = UDT7::Tidy_Up_Test_Data[]%0A%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,1,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Integer_Number_Scenarios%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Start_UDT_Tests,2,,,
codeblock,[] = UDT3::Create_Report_Data[]%0A%0AThis_Final_Test = create Final_Test_Data with Final_Test_Number = 0%0A%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,2,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Start_UDT_Tests%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Finish_UDT_Tests,3,,,
codeblock,[] = UDT4::Delete_Report_Data[]%0A%0AFTD_To_Delete = find-one Final_Test_Data%0A%0Aif FTD_To_Delete != UNDEFINED then%0A%0A   delete FTD_To_Delete%0A%0Aendif%0A%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,3,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Finish_UDT_Tests%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Real_Numbers_Scenario,4,,,
codeblock,#Call object based synchronous service%0A%0Amy_final_test = find-one Final_Test_Data%0A%0ATest = my_final_test.Final_Test_Number%0A%0ANew_Object   = TRUE%0AFinal_Object = FALSE%0A%0ADummy_TD = create Test_Data with The_Test_Number = 99 & Testing_For_What = "Nothing"%0A%0AA_Test_Data_IH = Dummy_TD%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C Dummy_TD%2C     Test%2C "Object data assignment"%2C Final_Object]%0A%0A# Don't need this beasty any more%2C it was only ever a dummy.%0Adelete Dummy_TD%0A%0ANew_Object = FALSE%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Max value assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Min value assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Common local assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Unique local assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Unique local assignment"%2C Final_Object]%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Min plus max"%2C Final_Object]%0A%0AFinal_Object = TRUE%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Report Number Of UDTs"%2C Final_Object]%0A%0Alocal_counter = 8%0A%0Aif A_Test_Data_IH != UNDEFINED then%0A  %0A   [] = RL1:Check_The_Reals[local_counter%2C A_Test_Data_IH.Testing_For_What%2C "1241-0000-01-0111"]%0A%0A   loop%0A%0A      breakif local_counter = Test%0A      local_counter = local_counter + 1%0A %0A      A_Test_Data_IH = A_Test_Data_IH -> R1."Has_a".Test_Data   %0A%0A      if A_Test_Data_IH != UNDEFINED then%0A%0A         if local_counter = 14 then%0A            [] = RL1:Check_The_Reals[local_counter%2C A_Test_Data_IH.Testing_For_What%2C "Null Requid"]%0A         endif%0A%0A         if local_counter != 14 and local_counter !=15 then%0A            [] = RL1:Check_The_Reals[local_counter%2C A_Test_Data_IH.Testing_For_What%2C"1241-0000-01-0111"]%0A         endif%0A%0A         if local_counter = 15 then%0A            [] = UDT5::Report_No_UDT_Used[local_counter%2C A_Test_Data_IH.Testing_For_What]%0A         endif%0A%0A      else%0A         # Oops%0A         break%0A      endif%0A%0A   endloop%0A%0Aelse%0A   [] = RPT5:Test_Text[local_counter%2C "First Test Data object corrupt"]%0Aendif%0A%0A# Tidy up the test data objects starting at the final one%0A%0A[] = UDT7::Tidy_Up_Test_Data[]%0A%0A%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,4,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Real_Numbers_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Predeclared_Integer_Scenario,5,,,
codeblock,#--------------------------------------------------------------------------%0A# Call domain based synchronous service%0A#--------------------------------------------------------------------------%0A%0Amy_final_test = find-one Final_Test_Data%0A%0ATest = my_final_test.Final_Test_Number%0A%0ANew_Object   = TRUE%0AFinal_Object = FALSE%0A%0ADummy_TD = create Test_Data with The_Test_Number = 99 & Testing_For_What = "Nothing"%0A%0AA_Test_Data_IH = Dummy_TD%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C Dummy_TD%2C     Test%2C "Object data assignment"%2C Final_Object]%0A%0A# Don't need this beasty any more%2C it was only ever a dummy.%0Adelete Dummy_TD%0A%0ANew_Object = FALSE%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Unique local assignment"%2C Final_Object]%0A%0AFinal_Object = TRUE%0A%0A[A_Test_Data_IH%2C Test] = UDT6::Create_New_Test_Data_Object_And_Link_It[New_Object%2C A_Test_Data_IH%2C Test%2C "Reuse predeclared local data"%2C Final_Object]%0A%0Alocal_counter = 15%0A%0Aif A_Test_Data_IH != UNDEFINED then%0A  %0A   [] = UDT2::Check_The_Predeclared_Integers[local_counter%2C A_Test_Data_IH.Testing_For_What]%0A%0A   loop%0A%0A      breakif local_counter = Test%0A      local_counter = local_counter + 1%0A %0A      A_Test_Data_IH = A_Test_Data_IH -> R1."Has_a".Test_Data   %0A%0A      if A_Test_Data_IH != UNDEFINED then%0A         [] = UDT2::Check_The_Predeclared_Integers[local_counter%2C A_Test_Data_IH.Testing_For_What]%0A      else%0A         # Oops%0A         break%0A      endif%0A%0A   endloop%0A%0Aelse%0A   [] = RPT5:Test_Text[local_counter%2C "First Test Data object corrupt"]%0Aendif%0A%0A# Tidy up the test data objects starting at the final one%0A%0A[] = UDT7::Tidy_Up_Test_Data[]%0A%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,5,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Predeclared_Integer_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Terminator_Type_Scenario,6,,,
codeblock,%0A#--------------------------------------------------------------------------%0A# This scenario shall prove that a data object instance handle passed into%0A# a terminator shall have its' attribute types passed in correctly.%0A#%0A# The locally defined data objects in the terminator should not have any %0A# defined type assinged to them by the code generator%2C ie. they should be %0A# base types. %0A#%0A# A secondary test has been defined where the data attributes of the object%0A# are passed in directly. This too should prove that locally defined %0A# objects do not inherit the type of the attribute or object that they are %0A# being assigned. %0A#%0A# Given the difference in the way I-SIM and WACA deal with UDT's%2C the tests%0A# will always pass in I-SIM%2C and cause a run-time error in WACA if ranges %0A# are exceeded.%0A#%0A# The thrust of the tests will be to force a range overflow in the UDT %0A# defined object in the terminator. If there are no UDT types associated %0A# with the local object in the terminator%2C then the test will pass%2C if the%0A# object has inherited the type%2C then the test will crash spectacularly.%0A#--------------------------------------------------------------------------%0A%0Amy_test = find-one Final_Test_Data%0A%0Athe_test_number = my_test.Final_Test_Number%0A%0Athe_result = FALSE%0A%0A#--------------------------------------------------------------------------%0A# Test 1 %0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[the_test_number%2C "1103-0000-01-0311"%2C "UDT"%2C "Terminator typing"%2C "Pass in object IH%2C decode types"]%0A%0A   the_IH = create unique Object_Into_Bridge with Current_State = 'Idle'%0A%0A   the_IH.A_Number = 10%0A   the_IH.Some_Enumeration = 'Four'%0A%0A   # with 101%2C 'Four'%0A%0A   [the_result%2C result_value] = BTF1:I_H_Type_Across[the_IH]%0A%0A   if the_result = TRUE then %0A      [] = RPT2:Test_Passed["Decode IH"%2C the_test_number%2C result_value]%0A   else%0A      [] = RPT3:Test_Failed["Decode IH"%2C the_test_number%2C result_value]%0A   endif%0A%0A   the_test_number = the_test_number + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[the_test_number%2C "1103-0000-01-0311"%2C "UDT"%2C "Terminator typing"%2C "Pass in UDT data%2C decode types"]%0A%0A   [the_result%2C result_value%2C result_subtype] = BTF2:User_Defined_Types_Across[the_IH.A_Number%2C the_IH.Some_Enumeration]%0A%0A   if the_result = TRUE then%0A      [] = RPT2:Test_Passed["Decode object"%2C the_test_number%2C result_value]%0A   else%0A      [] = RPT3:Test_Failed["Decode object"%2C the_test_number%2C result_value]%0A   endif%0A%0A   the_test_number = the_test_number + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3%0A#--------------------------------------------------------------------------%0A%0A   generate OIB1:Start_To_Test(the_test_number) to the_IH%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A%0A   the_test_number = the_test_number + 1%0A%0A   my_test.Final_Test_Number = the_test_number,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,6,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Terminator_Type_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Events_UDT_Scenario,7,,,
codeblock,my_test = find-one Final_Test_Data%0A%0AThis_Test_Number = my_test.Final_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   this_object = create An_Active_Object with The_Test_Number = This_Test_Number & Why = 'Not_Tested' & Current_State = 'Idle'%0A%0A   generate AAO1:Go('One') to this_object%0A%0A   This_Test_Number = This_Test_Number + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = BTF4:Local_Bridge[This_Test_Number]%0A%0A   This_Test_Number = This_Test_Number + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A%0Amy_test.Final_Test_Number = This_Test_Number%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,7,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Events_UDT_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Timer_Enum_Scenario,8,,,
codeblock,my_test = find-one Final_Test_Data%0A%0ATest = my_test.Final_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   [] = BTF5:Timer_Enum_Across_Bridge[Test]%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A%0Amy_test.Final_Test_Number = Test%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,8,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Timer_Enum_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Enum_Scenario,9,,,
codeblock,my_final_test = find-one Final_Test_Data%0A%0ATest = my_final_test.Final_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   [] = UDT10::Check_The_Enumerators[Test%2C 'Five'%2C 'Blue'%2C 'Freezing']%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A%0Amy_final_test.Final_Test_Number = Test %0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,9,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Enum_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,private,Check_Constraint,10,,,
codeblock,my_final_test = find-one Final_Test_Data%0A%0ATest = my_final_test.Final_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   [] = UDT11::Check_Constraint[Test]%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A%0Amy_final_test.Final_Test_Number = Test ,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,10,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Check_Constraint%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Check_The_Integers,1,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,The_Requid,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,# type subset_1_of_integer is          integer range      1 .. 10%0A# type subset_minus_1_of_integer is    integer range    -10 .. -1%0A# type subset_zero_of_integer is       integer range    -10 .. 10%0A# type one_to_maximum_integer is       integer range      1 .. 32767%0A# type zero_to_maximum_integer is      integer range      0 .. 32767%0A# type minus_one_to_maximum_integer is integer range     -1 .. 32767%0A# type minimum_to_minus_one_integer is integer range -32768 .. -1%0A# type minimum_to_zero_integer is      integer range -32768 .. 0%0A# type minimum_to_maximum_integer is   integer range -32768 .. 32767%0A%0A%0A#First_Integer  is Subset_1_of_Integer%0A#Second_Integer is Subset_minus_1_Of_Integer%0A#Third_Integer  is Subset_Zero_of_Integer%0A#Fourth_Integer is one_to_maximum_integer%0A#Fifth_Integer  is minimum_to_minus_one_integer%0A#Sixth_Integer  is minimum_to_maximum_integer%0A%0A   [] = RPT1:Start_Test[Test%2C The_Requid%2C "User Defined Types"%2C "Integer assignment"%2C Testing_For]%0A%0A   # Set up some negative numbers. I-SIM doesn't like assigning a magic %0A   # negative number to an attribute. %0A%0A   # These are defined by I-SIM as of base type.%0A   Minus_Ten    = -10%0A   Minus_Max    = -32768%0A   Minus_One    = -1%0A   Plus_One     =  1%0A   Plus_Ten     =  10%0A   Plus_Max     =  32767%0A   Big_Fat_Zero =  0%0A%0A   Test_Has_Passed  = FALSE%0A   Failure_Code = Big_Fat_Zero%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - This test shall prove that assignment using magic numbers is %0A#          handled correctly. %0A#          Note that these magic numbers are base type%2C and assinging them %0A#          to an attribute of UDT is what we are really looking at here.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 1 then%0A%0A      [] = RPT9:Specify_A_Requid[Test%2C "1103-0000-01-0311"]%0A%0A      The_Object = create Object_With_Integers with Unique_Identifier = Test%0A%0A      The_Object.First_Integer  = 1%0A      The_Object.Second_Integer = Minus_Ten %0A      The_Object.Third_Integer  = 10%0A      The_Object.Fourth_Integer = 1%0A      The_Object.Fifth_Integer  = Minus_Max%0A      The_Object.Sixth_Integer  = 0%0A%0A      if The_Object.First_Integer  = Plus_One   then%0A      %0A         if The_Object.Second_Integer = Minus_Ten  then%0A%0A            if The_Object.Third_Integer  = Plus_Ten   then%0A%0A               if The_Object.Fourth_Integer = Plus_One   then%0A%0A                  if The_Object.Fifth_Integer  = Minus_Max  then%0A%0A                     if The_Object.Sixth_Integer  = Big_Fat_Zero then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-60)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-50)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-40)%0A               endif%0A%0A            else%0A               Failure_Code = (-30)%0A            endif%0A%0A         else%0A            Failure_Code = (-20)%0A         endif%0A%0A      else%0A          Failure_Code = (-10)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 - This test shall prove that assignment using magic numbers is %0A#          handled correctly. %0A#          Note that these magic numbers are base type%2C and assinging them %0A#          to an attribute of UDT is what we are really looking at here.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 2 then%0A%0A      [] = RPT9:Specify_A_Requid[Test%2C "1103-0000-01-0311"]%0A%0A      The_Object = create Object_With_Integers with Unique_Identifier = Test%0A%0A      The_Object.First_Integer  = Plus_One%0A      The_Object.Second_Integer = Minus_Ten%0A      The_Object.Third_Integer  = Plus_Ten%0A      The_Object.Fourth_Integer = Plus_One%0A      The_Object.Fifth_Integer  = Minus_Max%0A      The_Object.Sixth_Integer  = Big_Fat_Zero%0A%0A      if (The_Object.First_Integer  = Plus_One) then%0A%0A         if (The_Object.Second_Integer = Minus_Ten) then%0A%0A            if (The_Object.Third_Integer  = Plus_Ten) then%0A%0A               if (The_Object.Fourth_Integer = Plus_One) then%0A%0A                  if (The_Object.Fifth_Integer  = Minus_Max) then%0A%0A                     if (The_Object.Sixth_Integer  = Big_Fat_Zero) then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-60)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-50)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-40)%0A               endif%0A%0A            else%0A               Failure_Code = (-30)%0A            endif%0A%0A         else%0A            Failure_Code = (-20)%0A         endif%0A%0A      else%0A         Failure_Code = (-10)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - This test shall prove that assignment using data objects is %0A#          handled correctly.  Values set to minimum allowable for range.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 3 then%0A%0A      [] = RPT9:Specify_A_Requid[Test%2C "1103-0000-01-0311"]%0A%0A      The_Object = create Object_With_Integers with Unique_Identifier = Test%0A%0A      The_Object.First_Integer  = Plus_Ten%0A      The_Object.Second_Integer = Minus_One%0A      The_Object.Third_Integer  = Plus_Ten%0A      The_Object.Fourth_Integer = Plus_Max%0A      The_Object.Fifth_Integer  = Minus_One%0A      The_Object.Sixth_Integer  = Plus_Max%0A%0A      if (The_Object.First_Integer  = Plus_Ten) then%0A%0A         if (The_Object.Second_Integer = Minus_One) then%0A%0A            if (The_Object.Third_Integer  = Plus_Ten) then%0A%0A               if (The_Object.Fourth_Integer = Plus_Max) then%0A%0A                  if (The_Object.Fifth_Integer  = Minus_One) then%0A%0A                     if (The_Object.Sixth_Integer  = Plus_Max) then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-60)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-50)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-40)%0A               endif%0A%0A            else%0A               Failure_Code = (-30)%0A            endif%0A%0A         else%0A            Failure_Code = (-20)%0A         endif%0A%0A      else%0A          Failure_Code = (-10)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - This test shall prove that assignment using data objects is %0A#          handled correctly.  Values set to maximum allowable for range.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 4 then%0A%0A      [] = RPT9:Specify_A_Requid[Test%2C "1103-0000-01-0311"]%0A%0A      The_Object = create Object_With_Integers with Unique_Identifier = Test%0A%0A      The_Object.First_Integer  = Plus_One%0A      The_Object.Second_Integer = Minus_Ten%0A      The_Object.Third_Integer  = Minus_Ten%0A      The_Object.Fourth_Integer = Plus_One%0A      The_Object.Fifth_Integer  = Minus_Max%0A      The_Object.Sixth_Integer  = Minus_Max%0A%0A      if (The_Object.First_Integer = Plus_One) then%0A%0A         if (The_Object.Second_Integer = Minus_Ten) then%0A%0A            if (The_Object.Third_Integer = Minus_Ten) then%0A%0A               if (The_Object.Fourth_Integer = Plus_One) then%0A%0A                  if (The_Object.Fifth_Integer = Minus_Max) then%0A%0A                     if (The_Object.Sixth_Integer = Minus_Max)  then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-60)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-50)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-40)%0A               endif%0A%0A            else%0A               Failure_Code = (-30)%0A            endif%0A%0A         else%0A            Failure_Code = (-20)%0A         endif%0A%0A      else%0A         Failure_Code = (-10)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - This test shall prove that I_SIM allows root data types to be %0A#          used for User Defined Types%2C and in fact totally ignores data%0A#          typing.%0A#          Also note that the local data objects are UDT type%2C and reused %0A#          by each assingment. This will cause problems for WACA as first %0A#          use for a local object should defined it as being the same type %0A#          as the attribute that is being copied into it. Subsequent copies %0A#          should cause grief.%0A#          This test has been modified to use unique local data and results %0A#          identifiers. Non-unique data (ie. reused local objects) has been %0A#          shown to cause a constraint error exception to be generated in %0A#          ADA. This is not a surprise.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 5 then%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Plus_One%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_Max%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A %0A      The_Object2.First_Integer  = Plus_One%0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Minus_Ten%0A      The_Object2.Fourth_Integer = Plus_One%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # 1 + 1 in range 1..10 result 2 in range%0A      Local_Integer1 = The_Object1.First_Integer  %0A      Local_Integer2 = The_Object2.First_Integer%0A      Result_Integer12 = Local_Integer1 + Local_Integer2%0A      Result_Object.First_Integer  =  Result_Integer12%0A%0A      # -10 - -1 in range -10 .. -1 result -9 inside range%0A      Local_Integer3 = The_Object1.Second_Integer  %0A      Local_Integer4 = The_Object2.Second_Integer%0A      Result_Integer34 = Local_Integer3 - Local_Integer4%0A      Result_Object.Second_Integer  =  Result_Integer34%0A%0A      # -10 - -10 in range -10 .. 10 result 0 inside range%0A      Local_Integer5 = The_Object1.Third_Integer  %0A      Local_Integer6 = The_Object2.Third_Integer%0A      Result_Integer56 = Local_Integer5 - Local_Integer6%0A      Result_Object.Third_Integer  =  Result_Integer56%0A  %0A      # 32767 - 1 in range 1..32767 result 32766 inside range%0A      Local_Integer7 = The_Object1.Fourth_Integer  %0A      Local_Integer8 = The_Object2.Fourth_Integer%0A      Result_Integer78 = Local_Integer7 - Local_Integer8%0A      Result_Object.Fourth_Integer  =  Result_Integer78%0A%0A      # -32768 - -1 in range -32768 .. -1 result -32767 inside range%0A      Local_Integer9 = The_Object1.Fifth_Integer  %0A      Local_Integer10 = The_Object2.Fifth_Integer%0A      Result_Integer910 = Local_Integer9 - Local_Integer10%0A      Result_Object.Fifth_Integer  =  Result_Integer910%0A %0A      # -32768 + 32767 in range -32768 .. 32767 result -1 inside range%0A      Local_Integer11 = The_Object1.Sixth_Integer  %0A      Local_Integer12 = The_Object2.Sixth_Integer%0A      Result_Integer1112 = Local_Integer11 + Local_Integer12%0A      Result_Object.Sixth_Integer  =  Result_Integer1112%0A  %0A      # Non unique binary operands%0A      if Result_Integer12 = Result_Object.First_Integer  &\%0A         Result_Integer34 = Result_Object.Second_Integer &\%0A         Result_Integer56 = Result_Object.Third_Integer  &\%0A         Result_Integer78 = Result_Object.Fourth_Integer &\%0A         Result_Integer910 = Result_Object.Fifth_Integer  &\%0A         Result_Integer1112 = Result_Object.Sixth_Integer then%0A%0A         Test_Has_Passed = TRUE%0A         Failure_Code    = 0%0A      else%0A         Failure_Code = -10%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - This test proves that individual local data objects must be used %0A#          for different data types.%0A#          This test is the same as test 5%2C with one important difference. %0A#          The local data objects are not reused%2C thus first use should  %0A#          specify them as of the attribute's type%2C and no conflict should %0A#          arise.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 6 then%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Plus_One%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_Max%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A%0A      The_Object2.First_Integer  = Plus_One%0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Minus_Ten%0A      The_Object2.Fourth_Integer = Plus_One%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # 1 + 1 in range 1..10 result 2 in range%0A      Local_Integer61 = The_Object1.First_Integer  %0A      Local_Integer62 = The_Object2.First_Integer%0A      Result_Integer612 = Local_Integer61 + Local_Integer62%0A      Result_Object.First_Integer = Result_Integer612%0A%0A      # -10 - -1 in range -10 .. -1 result -9 inside range%0A      Local_Integer64 = The_Object1.Second_Integer  %0A      Local_Integer65 = The_Object2.Second_Integer%0A      Result_Integer645 = Local_Integer64 - Local_Integer65%0A      Result_Object.Second_Integer = Result_Integer645%0A%0A      # -10 - -10 in range -10 .. 10 result 0 inside range%0A      Local_Integer67 = The_Object1.Third_Integer  %0A      Local_Integer68 = The_Object2.Third_Integer%0A      Result_Integer678 = Local_Integer67 - Local_Integer68%0A      Result_Object.Third_Integer  =  Result_Integer678%0A%0A      # 32767 - 1 in range 1..32767 result 32766 inside range%0A      Local_Integer610 = The_Object1.Fourth_Integer  %0A      Local_Integer611 = The_Object2.Fourth_Integer%0A      Result_Integer61011 = Local_Integer610 - Local_Integer611%0A      Result_Object.Fourth_Integer  =  Result_Integer61011%0A%0A      # -32768 - -1 in range -32768 .. -1 result -32767 inside range%0A      Local_Integer613 = The_Object1.Fifth_Integer  %0A      Local_Integer614= The_Object2.Fifth_Integer%0A      Result_Integer61314 = Local_Integer613 - Local_Integer614%0A      Result_Object.Fifth_Integer  =  Result_Integer61314%0A%0A      # -32768 + 32767 in range -32768 .. 32767 result -1 inside range%0A      Local_Integer616 = The_Object1.Sixth_Integer  %0A      Local_Integer617 = The_Object2.Sixth_Integer%0A      Result_Integer61617 = Local_Integer616 + Local_Integer617%0A      Result_Object.Sixth_Integer  =  Result_Integer61617%0A%0A      # Unique result_integer's and binary operands%0A      if Result_Integer612 = Result_Object.First_Integer  &\%0A         Result_Integer645 = Result_Object.Second_Integer &\%0A         Result_Integer678 = Result_Object.Third_Integer  &\%0A         Result_Integer61011 = Result_Object.Fourth_Integer &\%0A         Result_Integer61314 = Result_Object.Fifth_Integer  &\%0A         Result_Integer61617 = Result_Object.Sixth_Integer then%0A%0A         Test_Has_Passed = TRUE%0A         Failure_Code    = 0%0A      else%0A         Failure_Code = -10%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - This test proves that individual local data objects must be used %0A#          for different datatypes.%0A#%0A#          Add max values to minimum values.%0A#%0A#          This test shall cause some attributes to go out of range on%0A#          assignment to the results object attributes.%0A#%0A#          It is unclear what is to happen about this. %0A#%0A#          It highlights an important distinction between I-SIM and WACA. %0A#          UDT ARE TOTALLY UNSUPPORTED IN I-SIM%2C and trying to test for %0A#          them here will give erroneous results.%0A#%0A#          ADA will not allow this test to procede without exceptions being%0A#          generated. Therefore these tests have been commented out for the%0A#          moment.%0A#--------------------------------------------------------------------------%0A%0A   if Test = 7 then%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Plus_One%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_One%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A%0A      The_Object2.First_Integer  = Plus_Ten%0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Plus_Ten%0A      The_Object2.Fourth_Integer = Plus_Max%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # REUSE local_integer1 and 2 with different types. Should cause the Code Gen to %0A      # issue a warning.%0A  %0A      # 1 + 10 in range 1 .. 10 result 11 outside range%0A      #   Local_Integer1 = The_Object1.First_Integer  %0A      #   Local_Integer2 = The_Object2.First_Integer%0A      #   Result_Integer3 = Local_Integer1 + Local_Integer2%0A      #   Result_Object.First_Integer  =  Result_Integer3%0A%0A      # -10 - 1 in rnage -10 .. -1 result -11 outide range%0A      #   Local_Integer1 = The_Object1.Second_Integer  %0A      #   Local_Integer2 = The_Object2.Second_Integer%0A      #   Result_Integer3 = Local_Integer1 - Local_Integer2%0A      #   Result_Object.Second_Integer  =  Result_Integer3%0A%0A      # -10 - 1 in rnage -10 .. -1 result -11 outide range%0A      #   Local_Integer4 = The_Object1.Second_Integer  %0A      #   Local_Integer5 = The_Object2.Second_Integer%0A      #   Result_Integer6 = Local_Integer4 - Local_Integer5%0A      #   Result_Object.Second_Integer  =  Result_Integer6%0A%0A      # -10 - 10 in range -10 .. 10 result -20 outside range%0A      #   Local_Integer7 = The_Object1.Third_Integer  %0A      #   Local_Integer8 = The_Object2.Third_Integer%0A      #   Result_Integer9 = Local_Integer7 - Local_Integer8%0A      #   Result_Object.Third_Integer  =  Result_Integer9%0A%0A      # 1 + 32767 in range 1 .. 32767 result 32768 outside range%0A      #   Local_Integer10 = The_Object1.Fourth_Integer  %0A      #   Local_Integer11 = The_Object2.Fourth_Integer%0A      #   Result_Integer12 = Local_Integer10 + Local_Integer11%0A      #   Result_Object.Fourth_Integer  =  Result_Integer12%0A%0A      # -32768 + -1 in range -32768 .. 0 result  -32769 outside range%0A      #   Local_Integer13 = The_Object1.Fifth_Integer  %0A      #   Local_Integer14= The_Object2.Fifth_Integer%0A      #   Result_Integer15 = Local_Integer13 + Local_Integer14%0A      #   Result_Object.Fifth_Integer  =  Result_Integer15%0A%0A      # -32768 - 32767 in range -32768 .. 32767 result 65535 outside range%0A      #   Local_Integer16 = The_Object1.Sixth_Integer  %0A      #   Local_Integer17 = The_Object2.Sixth_Integer%0A      #   Result_Integer18 = Local_Integer16 + Local_Integer17%0A      #   Result_Object.Sixth_Integer  =  Result_Integer18%0A   %0A      # Unique result_integer's and binary operands%0A%0A      #   if Result_Integer3 = Result_Object.First_Integer  then %0A      # &\%0A      #      Result_Integer6 = Result_Object.Second_Integer &\%0A      #      Result_Integer9 = Result_Object.Third_Integer  &\%0A      #      Result_Integer12 = Result_Object.Fourth_Integer &\%0A      #      Result_Integer15 = Result_Object.Fifth_Integer  &\%0A      #      Result_Integer18 = Result_Object.Sixth_Integer then%0A%0A      #      Test_Has_Passed = TRUE%0A%0A      #  else%0A%0A      #      Failure_Code = -1%0A%0A      #   endif%0A%0A%0A    Failure_Code = 0%0A%0A       delete The_Object1%0A       delete The_Object2%0A%0A    endif%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A# End of tests%0A#--------------------------------------------------------------------------%0A%0A   if Test_Has_Passed then%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Failure_Code]%0A   else%0A%0A      if Failure_Code = Big_Fat_Zero then%0A         [] = RPT4:Test_Unsupported[Test]%0A      else%0A         [] = RPT3:Test_Failed[Testing_For%2C Test%2C Failure_Code]%0A      endif%0A%0A   endif%0A%0A   if Result_Object != UNDEFINED then%0A      delete Result_Object%0A   endif%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Create_Report_Data,3,,,
codeblock,# Find out of there already is one of these.%0A# It is not inconceivable that a report object still exists from a previous run.%0A# Report objects are not deleted at the end of a run%2C as certain events may%0A# still be en-queued.%0A%0Aold_report = find-one Report_Data%0A%0Aif old_report != UNDEFINED then%0A   delete old_report%0Aendif%0A%0AMy_Report = create unique Report_Data with Reported_Domain_Number = 0%0A%0A[] = RPT6:Domain_Test_Start["User Defined Types"]%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Delete_Report_Data,4,,,
codeblock,[] = RPT7:Domain_Test_Finished["User Defined Types"]%0A%0A# Do not delete the Report_Data object%2C as there may be still events in%0A# the queue.,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Create_New_Test_Data_Object_And_Link_It,6,,,
parameter,New_Set,in,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,Previous_IH,in,,,,,,
typeref,instance of Test_Data,,,,,,,
typeref,,,,,,,,
parameter,This_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Final_Entry,in,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,Returned_IH,out,,,,,,
typeref,instance of Test_Data,,,,,,,
typeref,,,,,,,,
parameter,Returned_Test_Number,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,if New_Set = TRUE then%0A%0A   Returned_IH = create Test_Data with The_Test_Number = This_Test_Number & Testing_For_What = Testing_For%0A%0A   Returned_Test_Number = This_Test_Number + 1%0A%0Aelse%0A%0A   # Add new Test_Data object onto Previous_IH%0A%0A   local_Test_Data_IH = create Test_Data with The_Test_Number = This_Test_Number & \%0A      Testing_For_What = Testing_For%0A%0A   link Previous_IH R1."Has_a" local_Test_Data_IH%0A%0A   if Final_Entry = TRUE then%0A%0A      # Final entry shall cause the return of the first set in the sequence.%0A%0A      loop%0A%0A         # Bail out of the operation will return an undefined IH%0A         Local_Previous_IH = local_Test_Data_IH -> R1."Has_one".Test_Data%0A%0A         breakif Local_Previous_IH = UNDEFINED%0A%0A         local_Test_Data_IH = local_Test_Data_IH -> R1."Has_one".Test_Data%0A%0A      endloop%0A%0A   endif%0A%0A   Returned_IH = local_Test_Data_IH%0A   Returned_Test_Number = This_Test_Number + 1%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Tidy_Up_Test_Data,7,,,
codeblock,Final_Test = find-one Final_Test_Data%0A%0ALast_Test = 0%0A%0Aloop%0A%0A   {All_Test_Data} = find-all Test_Data%0A%0A   number_in_set = countof {All_Test_Data}%0A%0A   breakif number_in_set = 0%0A%0A   for Single_Instance in {All_Test_Data} do%0A%0A      Next_Instance = Single_Instance -> R1."Has_a".Test_Data%0A%0A      if Next_Instance = UNDEFINED then%0A%0A         # we have reached the last entry%2C check to see if it is the first also%0A%0A         if number_in_set > 1 then%0A            Previous_Entry = Single_Instance -> R1."Has_one".Test_Data%0A#            unlink Previous_Entry R1."Has_a" Single_Instance%0A            unlink Single_Instance R1."Has_one" Previous_Entry %0A         endif%0A%0A         if Last_Test <= Single_Instance.The_Test_Number then%0A%0A            Last_Test = Single_Instance.The_Test_Number%0A%0A         endif%0A%0A         delete Single_Instance%0A%0A     endif%0A%0A   endfor%0A%0Aendloop%0A%0Aif Final_Test.Final_Test_Number <= Last_Test then%0A%0A   Last_Test = Last_Test + 1%0A%0A   Final_Test.Final_Test_Number = Last_Test%0A%0Aendif,,,,,,,
codeblock,,,,,,,,
description, Remove a set of reflexive objects.%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Check_The_Predeclared_Integers,2,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,# type subset_1_of_integer is          integer range      1 .. 10%0A# type subset_minus_1_of_integer is    integer range    -10 .. -1%0A# type subset_zero_of_integer is       integer range    -10 .. 10%0A# type one_to_maximum_integer is       integer range      1 .. 32767%0A# type zero_to_maximum_integer is      integer range      0 .. 32767%0A# type minus_one_to_maximum_integer is integer range     -1 .. 32767%0A# type minimum_to_minus_one_integer is integer range -32768 .. -1%0A# type minimum_to_zero_integer is      integer range -32768 .. 0%0A# type minimum_to_maximum_integer is   integer range -32768 .. 32767%0A%0A#Local_Integer1  : Subset_1_Of_Integer%0A#Local_Integer3 : Subset_Minus_1_Of_Integer%0A#Local_Integer5  : Subset_Zero_Of_Integer%0A#Local_Integer7 : One_To_Maximum_Integer%0A#Local_Integer9  : Minimum_To_Minus_One_Integer%0A#Local_Integer11  : Minimum_To_Maximum_Integer%0A%0A%0A[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "User Defined Types"%2C "Predeclared Integer assignment"%2C Testing_For]%0A%0A%0A# Set up some negative numbers. I-SIM doesn't like assigning a magic %0A# negative number to an attribute. %0A%0A# These are defined by I-SIM as of base type.%0A%0AMinus_Ten    = -10%0AMinus_Max    = -32768%0AMinus_One    = -1%0APlus_One     =  1%0APlus_Ten     =  10%0APlus_Max     =  32767%0ABig_Fat_Zero =  0%0A%0ATest_Has_Passed  = FALSE%0AFailure_Code = Big_Fat_Zero%0A%0A#--------------------------------------------------------------------------%0A# Test 15%0A#--------------------------------------------------------------------------%0A%0A   if Test = 15 then%0A%0A      # This test shall prove that I_SIM allows root data types to be used for%0A      # User Defined Types%2C and in fact totally ignores data typing.%0A%0A      # Also note that the local data objects are UDT type%2C and reused by each%0A      # assingment. This will cause problems for WACA as first use for a local%0A      # object should defined it as being the same type as the attribute that%0A      # is being copied into it. Subsequent copies should cause grief.%0A%0A      # This test has been modified to use unique local data and results identifiers.%0A      # Non-unique data (ie. reused local objects) has been shown to cause a constraint %0A      # error exception to be generated in ADA. This is not a surprise.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Plus_One%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_Max%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A%0A      The_Object2.First_Integer  = Plus_One%0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Minus_Ten%0A      The_Object2.Fourth_Integer = Plus_One%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # 1 + 1 in range 1..10 result 2 in range%0A      Local_Integer1 = The_Object1.Second_Integer  %0A      Local_Integer2 = The_Object1.First_Integer%0A      Result_Integer12 = Local_Integer1 + Local_Integer2%0A      Result_Object.First_Integer  =  Result_Integer12%0A%0A      # -10 - -1 in range -10 .. -1 result -9 inside range%0A      Local_Integer3 = The_Object1.Second_Integer  %0A      Local_Integer4 = The_Object2.Second_Integer%0A      Result_Integer34 = Local_Integer3 - Local_Integer4%0A      Result_Object.Second_Integer  =  Result_Integer34%0A%0A      # -10 - -10 in range -10 .. 10 result 0 inside range%0A      Local_Integer5 = The_Object1.Third_Integer  %0A      Local_Integer6 = The_Object2.Third_Integer%0A      Result_Integer56 = Local_Integer5 - Local_Integer6%0A      Result_Object.Third_Integer  =  Result_Integer56%0A%0A      # 32767 - 1 in range 1..32767 result 32766 inside range%0A      Local_Integer7 = The_Object1.Fourth_Integer  %0A      Local_Integer8 = The_Object2.Fourth_Integer%0A      Result_Integer78 = Local_Integer7 - Local_Integer8%0A      Result_Object.Fourth_Integer  =  Result_Integer78%0A%0A      # -32768 - -1 in range -32768 .. -1 result -32767 inside range%0A      Local_Integer9 = The_Object1.Fifth_Integer  %0A      Local_Integer10 = The_Object2.Fifth_Integer%0A      Result_Integer910 = Local_Integer9 - Local_Integer10%0A      Result_Object.Fifth_Integer  =  Result_Integer910%0A%0A      # -32768 + 32767 in range -32768 .. 32767 result -1 inside range%0A      Local_Integer11 = The_Object1.Sixth_Integer  %0A      Local_Integer12 = The_Object2.Sixth_Integer%0A      Result_Integer1112 = Local_Integer11 + Local_Integer12%0A      Result_Object.Sixth_Integer  =  Result_Integer1112%0A%0A      # Non unique binary operands%0A      if Result_Integer12 = Result_Object.First_Integer  &\%0A         Result_Integer34 = Result_Object.Second_Integer &\%0A         Result_Integer56 = Result_Object.Third_Integer  &\%0A         Result_Integer78 = Result_Object.Fourth_Integer &\%0A         Result_Integer910 = Result_Object.Fifth_Integer  &\%0A         Result_Integer1112 = Result_Object.Sixth_Integer then%0A%0A          Test_Has_Passed = TRUE%0A%0A      else%0A        Failure_Code = -1%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 15%0A%0A#--------------------------------------------------------------------------%0A# Test 16%0A#--------------------------------------------------------------------------%0A%0A   if Test = 16 then%0A%0A      # This test proves that individual local data objects must be used for different data%0A      # types.%0A%0A      # This test is the same as test 5%2C with one important difference. The local%0A      # data objects are not reused%2C thus first use should specify them as %0A      # of the attribute's type%2C and no conflict should arise.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Plus_One%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_Max%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A%0A      The_Object2.First_Integer  = Plus_One%0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Minus_Ten%0A      The_Object2.Fourth_Integer = Plus_One%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # 1 + 1 in range 1..10 result 2 in range%0A      Local_Integer61 = The_Object1.First_Integer  %0A      Local_Integer62 = The_Object2.First_Integer%0A      Result_Integer612 = Local_Integer61 + Local_Integer62%0A      Result_Object.First_Integer = Result_Integer612%0A%0A      # -10 - -1 in range -10 .. -1 result -9 inside range%0A      Local_Integer64 = The_Object1.Second_Integer  %0A      Local_Integer65 = The_Object2.Second_Integer%0A      Result_Integer645 = Local_Integer64 - Local_Integer65%0A      Result_Object.Second_Integer = Result_Integer645%0A%0A      # -10 - -10 in range -10 .. 10 result 0 inside range%0A      Local_Integer67 = The_Object1.Third_Integer  %0A      Local_Integer68 = The_Object2.Third_Integer%0A      Result_Integer678 = Local_Integer67 - Local_Integer68%0A      Result_Object.Third_Integer  =  Result_Integer678%0A%0A      # 32767 - 1 in range 1..32767 result 32766 inside range%0A      Local_Integer610 = The_Object1.Fourth_Integer  %0A      Local_Integer611 = The_Object2.Fourth_Integer%0A      Result_Integer61011 = Local_Integer610 - Local_Integer611%0A      Result_Object.Fourth_Integer  =  Result_Integer61011%0A%0A      # -32768 - -1 in range -32768 .. -1 result -32767 inside range%0A      Local_Integer613 = The_Object1.Fifth_Integer  %0A      Local_Integer614= The_Object2.Fifth_Integer%0A      Result_Integer61314 = Local_Integer613 - Local_Integer614%0A      Result_Object.Fifth_Integer  =  Result_Integer61314%0A%0A      # -32768 + 32767 in range -32768 .. 32767 result -1 inside range%0A      Local_Integer616 = The_Object1.Sixth_Integer  %0A      Local_Integer617 = The_Object2.Sixth_Integer%0A      Result_Integer61617 = Local_Integer616 + Local_Integer617%0A      Result_Object.Sixth_Integer  =  Result_Integer61617%0A%0A      # Unique result_integer's and binary operands%0A%0A      if Result_Integer612   = Result_Object.First_Integer  &\%0A         Result_Integer645   = Result_Object.Second_Integer &\%0A         Result_Integer678   = Result_Object.Third_Integer  &\%0A         Result_Integer61011 = Result_Object.Fourth_Integer &\%0A         Result_Integer61314 = Result_Object.Fifth_Integer  &\%0A         Result_Integer61617 = Result_Object.Sixth_Integer then%0A%0A         Test_Has_Passed = TRUE%0A      else%0A         Failure_Code = -1%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 16%0A%0A#--------------------------------------------------------------------------%0A# Test 17%0A#--------------------------------------------------------------------------%0A%0A   if Test = 17 then%0A%0A      # This test proves that individual local data objects must be used for different data%0A      # types.%0A%0A      # Add max values to minimum values.%0A%0A      # This test shall cause some attributes to go out of range on assignment%0A      # to the results object attributes.%0A%0A      # Ada will raise a constraint error under these conditions.%0A%0A      # It highlights an important distinction between I-SIM and WACA. %0A      # UDT ARE TOTALLY UNSUPPORTED IN I-SIM%2C and trying to test for them here%0A      # will give erroneous results.%0A%0A      # ADA will not allow this test to procede without exceptions being generated. Therefore%0A      # these tests have been commented out for the moment.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Integers with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Integers with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Integers with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Integer  = Minus_Ten%0A%0A      The_Object1.Second_Integer = Minus_Ten%0A      The_Object1.Third_Integer  = Minus_Ten%0A      The_Object1.Fourth_Integer = Plus_One%0A      The_Object1.Fifth_Integer  = Minus_Max%0A      The_Object1.Sixth_Integer  = Minus_Max%0A%0A      The_Object2.First_Integer  = Plus_Ten%0A  %0A      The_Object2.Second_Integer = Minus_One%0A      The_Object2.Third_Integer  = Plus_Ten%0A      The_Object2.Fourth_Integer = Plus_Max%0A      The_Object2.Fifth_Integer  = Minus_One%0A      The_Object2.Sixth_Integer  = Plus_Max%0A%0A      # REUSE local_integer5 predeclared as subset_zero_of_integer and assign an attribute of%0A      # The_Object_1.First_Integer (which is of type Subset_1_Of_Integer)%0A%0A      # and local_integer_2 defined from first use as Subset_1_Of_Integer%0A%0A      # Adding the two should make Result_Integer_3 of type subset_zero_of_integer%0A%0A      # Assignment of The_Object1.First_Integer to Local_Integer5 should cause the Code Gen %0A      # to issue a warning.%0A%0A      # -10 + 10 in range -10 .. 10 result 0 inside range%0A      Local_Integer5 = The_Object1.First_Integer  %0A      Local_Integer2 = The_Object2.First_Integer%0A      Result_Integer3 = Local_Integer5 + Local_Integer2%0A      Result_Object.First_Integer  =  Result_Integer3%0A%0A      if Result_Integer3 = Big_Fat_Zero then %0A         Test_Has_Passed = TRUE%0A      else%0A         Test_Has_Passed = FALSE%0A         Failure_Code = Result_Integer3%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 17%0A%0A#--------------------------------------------------------------------------%0A# Report the results.%0A#--------------------------------------------------------------------------%0A%0Aif Test_Has_Passed then%0A%0A   if Result_Object = UNDEFINED then%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Failure_Code]%0A   else%0A      # This should cause problems for WACA%2C as the results attributes%0A      # are all of different types.%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.First_Integer]%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.Second_Integer]%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.Third_Integer]%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.Fourth_Integer]%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.Fifth_Integer]%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Result_Object.Sixth_Integer]%0A   endif%0A%0Aelse%0A%0A   if Failure_Code = Big_Fat_Zero then%0A      [] = RPT4:Test_Unsupported[Test]%0A   else%0A      [] = RPT3:Test_Failed[Testing_For%2C Test%2C Failure_Code]%0A   endif%0A%0Aendif%0A%0Aif Result_Object != UNDEFINED then%0A   delete Result_Object%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
description, As service 1%2C but predeclaring the local%0A variables rather than allowing first use to defined type.%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Report_No_UDT_Used,5,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,Reported_No_UDT = 0%0AExpected_No_UDT = 0%0ATest_Has_Passed = FALSE%0A%0A[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "User Defined Types"%2C "Reported No UDTs"%2C Testing_For]%0A%0Aif Test = 15 then%0A   [env] = BTF3:Get_Environment_Type[]%0A%0A   if env = 1 then%0A      [] = RPT4:Test_Unsupported[Test]   %0A   else%0A%0A      #$ADA_INLINE%0A         #with Ada.Text_IO;%0A         #%0A         #with UDT_Domain_Types;%0A         #Reported_No_UDT := UDT_Domain_Types.Types_And_Subtypes_Count;%0A         #Ada.Text_IO.Put_Line("No UDTs in User_Defined_Types = " & integer'image(integer(Reported_No_UDT)));%0A      #$END_ADAINLINE%0A%0A      $INLINE%0A         fprintf(stderr%2C"Checking number of UDTs \n");%0A      $ENDINLINE%0A%0A      Expected_No_UDT = 16%0A%0A      if Reported_No_UDT = Expected_No_UDT then%0A         [] = RPT2:Test_Passed[Testing_For%2C Test%2C Reported_No_UDT]%0A      else %0A         [] = RPT3:Test_Failed[Testing_For%2C Test%2C Expected_No_UDT]%0A      endif%0A%0A   endif%0A%0Aendif,,,,,,,
codeblock,,,,,,,,
description, Returns the number of user defined types used and confims that the reported number is actually the number used.%0A,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Create_An_Active_Object,8,,,
parameter,This_Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Returned_IH,out,,,,,,
typeref,instance of An_Active_Object,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,Returned_IH = create An_Active_Object with The_Test_Number = This_Test & Why = 'Not_Tested' & Current_State = 'Idle'%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Create_A_Timer_Enumeration,9,,,
parameter,The_Timer_Enum,in,,,,,,
typeref,Time_Unit,,,,,,,
typeref,,,,,,,,
parameter,The_Return_Value,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,The_Return_Value = -1%0A%0Aif The_Timer_Enum  = 'MILLISECOND' then%0A   The_Return_Value = 1%0Aendif   %0A%0Aif The_Timer_Enum = 'SECOND' then%0A   The_Return_Value = 2  %0Aendif,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Check_The_Enumerators,10,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,First_Enum_Input,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,Second_Enum_Input,in,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
parameter,Third_Enum_Input,in,,,,,,
typeref,Temp_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,#----------------------------------------------------------------------%0A# Test 1 - Check to ensure that attributes for an object can accept%0A#          enumerated user defined types%0A#----------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-0113"%2C "User Defined Types"%2C "Enumerator assignment"%2C "Sub ranges of enumerators"]%0A   [] = RPT9:Specify_A_Requid[Test%2C "1241-0000-01-1214"]%0A%0A   Defunct_Boy_Band = First_Enum_Input%0A   Bad_Boy_Band     = Second_Enum_Input%0A   Zero_Degrees     = Third_Enum_Input%0A   %0A   InstEnum = create Object_With_Enumerators with theID       = Test             &\%0A                                                  First_Enum  = Defunct_Boy_Band &\%0A                                                  Second_Enum = Bad_Boy_Band     &\%0A                                                  Third_Enum  = Zero_Degrees%0A%0A   Has_Failed   = TRUE%0A   Failure_Code = 0%0A%0A   if InstEnum.First_Enum = 'Five' then%0A%0A      if InstEnum.Second_Enum = 'Blue' then%0A%0A         if InstEnum.Third_Enum = 'Freezing' then%0A            Has_Failed = FALSE%0A         else%0A            Has_Failed   = TRUE%0A            Failure_Code = -10%0A         endif%0A%0A      else%0A         Has_Failed   = TRUE%0A         Failure_Code = -20%0A      endif%0A%0A   else%0A      Has_Failed   = TRUE%0A      Failure_Code = -30%0A   endif%0A%0A   delete InstEnum%0A%0A   # Report the results.%0A  %0A   if not Has_Failed then%0A      [] = RPT2:Test_Passed["Check Enumerators"%2C Test%2C Failure_Code]%0A   else%0A      [] = RPT3:Test_Failed["Check Enumerators"%2C Test%2C Failure_Code]%0A   endif%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Check_Constraint,11,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,# --------------------------------------------------------------------------------------%0A# Check that when a switch statment uses a contrained type default is not required as%0A# all elements of the constrained type should be accounted for%0A# --------------------------------------------------------------------------------------%0A%0A[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "User Defined Types"%2C "Check Constraint"%2C "Check Constraint in Switch"]%0A%0AHas_Failed   = TRUE%0AFailure_Code = -10%0ACount = 0%0A%0A%0A   The_Object = create Object_With_Integers with Unique_Identifier = Test%0A%0A   The_Object.First_Integer = 4%0A%0Aswitch The_Object.First_Integer%0A%0A   case 1%0A      Count = 1%0A%0A   case 2%0A      Count = 2%0A%0A   case 3%0A      Count = 3%0A%0A   case 4%0A      Count = 4%0A      Has_Failed = FALSE%0A%0A   case 5%0A      Count = 5%0A%0A   case 6%0A      Count = 6%0A%0A   case 7%0A      Count = 7%0A%0A   case 8%0A      Count = 8%0A%0A   case 9%0A      Count = 9%0A%0A   case 10%0A      Count = 10%0A%0Aendswitch%0A%0Adelete The_Object%0A%0Aif not Has_Failed then%0A   [] = RPT2:Test_Passed["Check Constraint in Switch"%2C Test%2C Count]%0Aelse%0A   [] = RPT3:Test_Failed["Check Constraint in Switch"%2C Test%2C Count]%0Aendif%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
terminator,Report,RPT,,,,,,
routine,UDT,,public,Start_Test,1,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Requid,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Invoking_Domain,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Invoking_Object,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Purpose,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Test_Passed,2,,,
parameter,Test_Object_Domain,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Test_Value,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Test_Failed,3,,,
parameter,Failed_Domain_Object,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Failed_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Failed_Test_Value,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Test_Unsupported,4,,,
parameter,Unsupported_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Test_Text,5,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Free_Text,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Domain_Test_Start,6,,,
parameter,This_Domain_Name,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Domain_Test_Finished,7,,,
parameter,This_Domain_Name,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Test_Real_Passed,8,,,
parameter,Passed_Domain,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Passed_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Test_Result,in,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,the_test = Passed_Test_Number%0A%0Athe_val  = Test_Result%0A%0Athe_domain = Passed_Domain%0A%0A$INLINE%0Afprintf(stderr%2C "Object %25s Test Number %25d has PASSED with  %256.2f\n"%2C%0A        the_domain%2C the_test%2C the_val);%0A$ENDINLINE%0A%0A%0A%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Specify_A_Requid,9,,,
parameter,Requid_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,The_Requid_Itself,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
terminator,,,,,,,,
terminator,Bridge_Too_Far,BTF,,,,,,
routine,UDT,,public,I_H_Type_Across,1,,,
parameter,Param1_IH,in,,,,,,
typeref,instance of Object_Into_Bridge,,,,,,,
typeref,,,,,,,,
parameter,Success,out,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,Success_Value,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,User_Defined_Types_Across,2,,,
parameter,Param1,in,,,,,,
typeref,Subset_Zero_Of_Integer,,,,,,,
typeref,,,,,,,,
parameter,Param2,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,Success,out,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,Success_Value,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Return_Param,out,,,,,,
typeref,One_To_Maximum_Integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Get_Environment_Type,3,,,
parameter,Type_Of_Environment,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,$INLINE%0A   fprintf(stderr%2C"STUB where are we\n");%0A$ENDINLINE%0A%0AType_Of_Environment = 0%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Local_Bridge,4,,,
parameter,This_Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,%0A%0A%0A[Second_Active_Object] = UDT8::Create_An_Active_Object[This_Test]%0A%0Agenerate AAO1:Go('One') to Second_Active_Object%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Timer_Enum_Across_Bridge,5,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
terminator,,,,,,,,
terminator,Timer,TIM,,,,,,
routine,UDT,,public,Set_Timer,0,,,
parameter,Timer_ID,in,,,,,,
typeref,Timer_ID,,,,,,,
typeref,,,,,,,,
parameter,Time_Remaining,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Granularity,in,,,,,,
typeref,Time_Unit,,,,,,,
typeref,,,,,,,,
parameter,Event_ID,in,,,,,,
typeref,event,,,,,,,
typeref,,,,,,,,
parameter,Instance_ID,in,,,,,,
typeref,instance,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Reset_Timer,0,,,
parameter,Timer_ID,in,,,,,,
typeref,Timer_ID,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,UDT,,public,Set_Absolute_Timer,0,,,
parameter,Timer_ID,in,,,,,,
typeref,Timer_ID,,,,,,,
typeref,,,,,,,,
parameter,Actual_Date,in,,,,,,
typeref,timestamp,,,,,,,
typeref,,,,,,,,
parameter,Actual_Time,in,,,,,,
typeref,duration,,,,,,,
typeref,,,,,,,,
parameter,Event_ID,in,,,,,,
typeref,event,,,,,,,
typeref,,,,,,,,
parameter,Instance_ID,in,,,,,,
typeref,instance,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
terminator,,,,,,,,
regularrel,R1,,,,,,,
participation,UDT,Test_Data,Has_a,unconditionally,one,UDT,Test_Data,
participation,UDT,Test_Data,Has_one,conditionally,one,UDT,Test_Data,
participation,,,,,,,,
pragma,Class_B,,,,,,,
pragmaitem,"Test_Data",,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
pragma,Class_A,,,,,,,
pragmaitem,"Test_Data",,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
regularrel,,,,,,,,
object,An_Active_Object,AAO,8,,,,,
attribute,The_Test_Number,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Why,,,The_Test_Number,,,,
typeref,Active_Object_Status_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
state,,An_Active_Object,Idle,,1,,,
state,,,,,,,,
state,,An_Active_Object,Do_It,,2,,,
parameter,Enum_Parameter,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,This_Test = this.The_Test_Number%0A%0A[] = RPT1:Start_Test[This_Test%2C "Null Requid"%2C "UDT"%2C "Active Object Enumeration"%2C "Hard coded enumeration"]%0A%0Aif Enum_Parameter = 'One' then%0A%0A   # It is worth noting at this point that the test number (base_integer_type) is%0A   # being stuffed into the parameter%2C which is defined as a subtype.%0A   # If the test number is greater than the range of the subtype%2C then%0A   # we will get a constraint error at run time.%0A%0A   # Ensure that the range of the subtype is sufficient to handle the %0A   # test number. This is a consequence of using subtypes in ada.%0A   # If we had used proper strong typing%2C this mish-mash wouldn't happen.%0A%0A   generate AAO2:Go_Again('Two'%2C this.The_Test_Number) to this%0A%0Aelse%0A%0A   this.Why = 'Enumeral'%0A   generate AAO3:Failed('Enumeral') to this%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,An_Active_Object,Do_It_Again,,3,,,
parameter,Enum_Parameter,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,Subset_Param,in,,,,,,
typeref,One_To_Maximum_Integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,if Enum_Parameter = 'Two' then%0A%0A   if Subset_Param = this.The_Test_Number then%0A      this.Why = 'OK'%0A      generate AAO4:Passed('OK') to this%0A   else%0A      this.Why = 'Number'%0A      generate AAO3:Failed('Number') to this%0A   endif%0A%0Aelse%0A   this.Why = 'Enumeral'%0A   generate AAO3:Failed('Enumeral') to this%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,An_Active_Object,It_Failed,,4,,,
parameter,Reason,in,,,,,,
typeref,Active_Object_Status_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,Failed_Because = 0%0A%0Aif Reason = 'Enumeral' then%0A   Failed_Because = 1%0Aelse%0A%0A   if Reason = 'Number' then%0A      Failed_Because = 2%0A   else%0A      Failed_Because = 9%0A   endif%0A%0Aendif%0A%0Athis_test = this.The_Test_Number%0A%0A[] = RPT3:Test_Failed["Active UDT Object"%2C this_test%2C  Failed_Because]%0A%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,An_Active_Object,It_Passed,,5,,,
parameter,Reason,in,,,,,,
typeref,Active_Object_Status_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,this_test = this.The_Test_Number%0A%0Aif this.Why = Reason then %0A%0A   if this.Why = 'OK' then%0A      [] = RPT2:Test_Passed["Active UDT Object"%2C this_test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["Active UDT Object"%2C this_test%2C  -99]%0A   endif%0A%0Aelse%0A      [] = RPT3:Test_Failed["Active UDT Object"%2C this_test%2C  -999]%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
event,Go,,1,,,,,
parameter,Enum_Parameter,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
event,Go_Again,,2,,,,,
parameter,Enum_Parameter,in,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
parameter,Subset_Param,in,,,,,,
typeref,One_To_Maximum_Integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
event,Failed,,3,,,,,
parameter,Reason,in,,,,,,
typeref,Active_Object_Status_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
event,Passed,,4,,,,,
parameter,Reason,in,,,,,,
typeref,Active_Object_Status_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
transitiontable,,,,,,,,
transition,Non_Existent,,,Go,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Go_Again,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Failed,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Passed,Cannot_Happen,,,
transition,,,,,,,,
transition,Idle,,,Go,Do_It,,,
transition,,,,,,,,
transition,Idle,,,Go_Again,Cannot_Happen,,,
transition,,,,,,,,
transition,Idle,,,Failed,Cannot_Happen,,,
transition,,,,,,,,
transition,Idle,,,Passed,Cannot_Happen,,,
transition,,,,,,,,
transition,Do_It,,,Go,Cannot_Happen,,,
transition,,,,,,,,
transition,Do_It,,,Go_Again,Do_It_Again,,,
transition,,,,,,,,
transition,Do_It,,,Failed,It_Failed,,,
transition,,,,,,,,
transition,Do_It,,,Passed,Cannot_Happen,,,
transition,,,,,,,,
transition,Do_It_Again,,,Go,Cannot_Happen,,,
transition,,,,,,,,
transition,Do_It_Again,,,Go_Again,Cannot_Happen,,,
transition,,,,,,,,
transition,Do_It_Again,,,Failed,It_Failed,,,
transition,,,,,,,,
transition,Do_It_Again,,,Passed,It_Passed,,,
transition,,,,,,,,
transition,It_Failed,,,Go,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Failed,,,Go_Again,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Failed,,,Failed,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Failed,,,Passed,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Passed,,,Go,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Passed,,,Go_Again,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Passed,,,Failed,Cannot_Happen,,,
transition,,,,,,,,
transition,It_Passed,,,Passed,Cannot_Happen,,,
transition,,,,,,,,
transitiontable,,,,,,,,
object,,,,,,,,
object,Final_Test_Data,FTD,7,,,,,
attribute,Final_Test_Number,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
object,Object_Into_Bridge,OIB,3,,,,,
attribute,Unique_Identifier,preferred,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,A_Number,,,Unique_Identifier,,,,
typeref,Subset_1_Of_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Some_Enumeration,,,A_Number,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
state,,Object_Into_Bridge,Idle,,1,,,
state,,,,,,,,
state,,Object_Into_Bridge,Testing,,2,,,
parameter,Where_To_Start,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
codeblock,#--------------------------------------------------------------------------%0A# pass the 'this' IH to a bridge for dereferencing.%0A#--------------------------------------------------------------------------%0A%0A[] = RPT1:Start_Test[Where_To_Start%2C "1103-0000-01-0311"%2C "UDT"%2C "Terminator typing"%2C "Pass in this IH%2C decode types"]%0A%0A[the_result%2C result_value] = BTF1:I_H_Type_Across[this]%0A%0Aif the_result = TRUE then%0A%0A   if this.Some_Enumeration = 'Four' then%0A      [] = RPT2:Test_Passed["Decode this IH"%2C Where_To_Start%2C result_value]%0A   else%0A      [] = RPT3:Test_Failed["Decode this IH"%2C Where_To_Start%2C result_value]%0A   endif%0A%0Aelse%0A   [] = RPT3:Test_Failed["Decode this IH"%2C Where_To_Start%2C result_value]%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
event,Start_To_Test,,1,,,,,
parameter,Where_To_Start,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
transitiontable,,,,,,,,
transition,Non_Existent,,,Start_To_Test,Cannot_Happen,,,
transition,,,,,,,,
transition,Idle,,,Start_To_Test,Testing,,,
transition,,,,,,,,
transition,Testing,,,Start_To_Test,Ignore,,,
transition,,,,,,,,
transitiontable,,,,,,,,
description, Pass the instance handle of this object into a bridge%0A,,,,,,,
object,,,,,,,,
object,Object_With_Enumerators,ENUM,9,,,,,
attribute,First_Enum,,,,,,,
typeref,Simple_Enumeration_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Second_Enum,preferred,,First_Enum,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Third_Enum,preferred,,Second_Enum,,,,
typeref,Temp_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,theID,,,Third_Enum,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
object,Object_With_Integers,INT,2,,,,,
attribute,First_Integer,,,,,,,
typeref,Subset_1_Of_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Second_Integer,,,First_Integer,,,,
typeref,Subset_Minus_1_Of_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Third_Integer,,,Second_Integer,,,,
typeref,Subset_Zero_Of_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Fourth_Integer,,,Third_Integer,,,,
typeref,One_To_Maximum_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Fifth_Integer,,,Fourth_Integer,,,,
typeref,Minimum_To_Minus_One_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Sixth_Integer,,,Fifth_Integer,,,,
typeref,Minimum_To_Maximum_Integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Unique_Identifier,preferred,,Sixth_Integer,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
object,Object_With_Reals,RL,6,,,,,
attribute,Unique_Identifier,preferred,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,First_Real,,,Unique_Identifier,,,,
typeref,Subset_1_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Second_Real,,,First_Real,,,,
typeref,Subset_Minus_1_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Third_Real,,,Second_Real,,,,
typeref,Subset_Zero_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Fourth_Real,,,Third_Real,,,,
typeref,One_To_Maximum_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Fifth_Real,,,Fourth_Real,,,,
typeref,Minimum_To_Minus_One_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Sixth_Real,,,Fifth_Real,,,,
typeref,Mminimum_To_Maximum_Of_Real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
operation,UDT,Object_With_Reals,public,Check_The_Reals,,,1,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,The_Requid,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,# type subset_1_of_real is          real range      1.0.. 10.0%0A# type subset_minus_1_of_real is    real range    -10.0 .. -1.0%0A# type subset_zero_of_real is       real range    -10.0 .. 10.0%0A# type one_to_maximum_real is       real range      1.0 .. 32767.0%0A# type zero_to_maximum_real is      real range      0.0 .. 32767.0%0A# type minus_one_to_maximum_real is real range     -1.0 .. 32767.0%0A# type minimum_to_minus_one_real is real range -32768.0 .. -1.0%0A# type minimum_to_zero_real is      real range -32768.0 .. 0.0%0A# type minimum_to_maximum_real is   real range -32768.0 .. 32767.0%0A%0A%0A#First_Real  is Subset_1_of_Real%0A#Second_Real is Subset_minus_1_Of_Real%0A#Third_Real  is Subset_Zero_of_Real%0A#Fourth_Real is one_to_maximum_real%0A#Fifth_Real  is minimum_to_minus_one_real%0A#Sixth_Real  is minimum_to_maximum_real%0A%0A[] = RPT1:Start_Test[Test%2C The_Requid%2C "User Defined Types"%2C "Real assignment"%2C Testing_For]%0A%0A# Set up some negative numbers. I-SIM doesn't like assigning a magic %0A# negative number to an attribute. %0A%0A# These are defined by I-SIM as of base type.%0A%0AMinus_Ten    = -10.0%0AMinus_Max    = -32768.0%0AMinus_One    = -1.0%0APlus_One     =  1.0%0APlus_Ten     =  10.0%0APlus_Max     =  32767.0%0ABig_Fat_Real_Zero =  0.0%0A%0ATest_Has_Passed  = FALSE%0AFailure_Code = 0%0A%0A#--------------------------------------------------------------------------%0A# Test 8%0A#--------------------------------------------------------------------------%0A%0A   if Test = 8 then%0A%0A      # This test shall prove that assignment using magic numbers is %0A      # handled correctly. %0A%0A      # Note that these magic numbers are base type%2C and assinging them to %0A      # an attribute of UDT is what we are really looking at here.%0A%0A      The_Object = create Object_With_Reals with Unique_Identifier = Test%0A%0A      The_Object.First_Real  = 1.0%0A      The_Object.Second_Real = Minus_Ten %0A      The_Object.Third_Real  = 10.0%0A      The_Object.Fourth_Real = 1.0%0A      The_Object.Fifth_Real  = Minus_Max%0A      The_Object.Sixth_Real  = 0.0%0A%0A      if The_Object.First_Real  = Plus_One   then%0A%0A         if The_Object.Second_Real = Minus_Ten  then%0A%0A            if The_Object.Third_Real  = Plus_Ten   then%0A%0A               if The_Object.Fourth_Real = Plus_One   then%0A%0A                  if The_Object.Fifth_Real  = Minus_Max  then%0A%0A                     if The_Object.Sixth_Real  = Big_Fat_Real_Zero then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-6)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-5)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-4)%0A               endif%0A   %0A            else%0A               Failure_Code = (-3)%0A            endif%0A%0A         else%0A            Failure_Code = (-2)%0A         endif%0A%0A      else%0A         Failure_Code = (-1)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 8%0A%0A#--------------------------------------------------------------------------%0A# Test 9%0A#--------------------------------------------------------------------------%0A%0A   if Test = 9 then%0A  %0A      # This test shall prove that assignment using data objects is %0A      # handled correctly. %0A%0A      # Note that these data objects are base type%2C and assinging them to %0A      # an attribute of UDT is what we are really looking at here.%0A%0A      The_Object = create Object_With_Reals with Unique_Identifier = Test%0A%0A      The_Object.First_Real  = Plus_One%0A      The_Object.Second_Real = Minus_Ten%0A      The_Object.Third_Real  = Plus_Ten%0A      The_Object.Fourth_Real = Plus_One%0A      The_Object.Fifth_Real  = Minus_Max%0A      The_Object.Sixth_Real  = Big_Fat_Real_Zero%0A%0A      if (The_Object.First_Real  = Plus_One  ) then%0A%0A         if (The_Object.Second_Real = Minus_Ten ) then%0A%0A            if (The_Object.Third_Real  = Plus_Ten  ) then%0A%0A               if (The_Object.Fourth_Real = Plus_One  ) then%0A%0A                  if (The_Object.Fifth_Real  = Minus_Max ) then%0A%0A                     if (The_Object.Sixth_Real  = Big_Fat_Real_Zero) then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-6)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-5)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-4)%0A               endif%0A%0A            else%0A               Failure_Code = (-3)%0A            endif%0A%0A         else%0A            Failure_Code = (-2)%0A         endif%0A%0A      else%0A         Failure_Code = (-1)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 9%0A%0A#--------------------------------------------------------------------------%0A# Test 10%0A#--------------------------------------------------------------------------%0A%0A   if Test = 10 then%0A%0A      # This test shall prove that assignment using data objects is %0A      # handled correctly.  Values set to minimum allowable for range.%0A%0A      The_Object = create Object_With_Reals with Unique_Identifier = Test%0A%0A      The_Object.First_Real  = Plus_Ten%0A      The_Object.Second_Real = Minus_One%0A      The_Object.Third_Real  = Plus_Ten%0A      The_Object.Fourth_Real = Plus_Max%0A      The_Object.Fifth_Real  = Minus_One%0A      The_Object.Sixth_Real  = Plus_Max%0A%0A      if (The_Object.First_Real  = Plus_Ten  ) then%0A%0A         if (The_Object.Second_Real = Minus_One ) then%0A%0A            if (The_Object.Third_Real  = Plus_Ten  ) then%0A%0A               if (The_Object.Fourth_Real = Plus_Max  ) then%0A%0A                  if (The_Object.Fifth_Real  = Minus_One ) then%0A%0A                     if (The_Object.Sixth_Real  = Plus_Max ) then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-6)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-5)%0A                  endif%0A   %0A               else%0A                  Failure_Code = (-4)%0A               endif%0A%0A            else%0A               Failure_Code = (-3)%0A            endif%0A%0A         else%0A            Failure_Code = (-2)%0A         endif%0A%0A      else%0A         Failure_Code = (-1)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 10%0A%0A#--------------------------------------------------------------------------%0A# Test 11%0A#--------------------------------------------------------------------------%0A%0A   if Test = 11 then%0A%0A      # This test shall prove that assignment using data objects is %0A      # handled correctly.  Values set to maximum allowable for range.%0A%0A      The_Object = create Object_With_Reals with Unique_Identifier = Test%0A%0A      The_Object.First_Real  = Plus_One%0A      The_Object.Second_Real = Minus_Ten%0A      The_Object.Third_Real  = Minus_Ten%0A      The_Object.Fourth_Real = Plus_One%0A      The_Object.Fifth_Real  = Minus_Max%0A      The_Object.Sixth_Real  = Minus_Max%0A%0A      if (The_Object.First_Real  = Plus_One  ) then%0A%0A         if (The_Object.Second_Real = Minus_Ten ) then%0A%0A            if (The_Object.Third_Real  = Minus_Ten  ) then%0A%0A               if (The_Object.Fourth_Real = Plus_One  ) then%0A%0A                  if (The_Object.Fifth_Real  = Minus_Max ) then%0A%0A                     if (The_Object.Sixth_Real  = Minus_Max ) then%0A                        Test_Has_Passed = TRUE%0A                     else%0A                        Failure_Code = (-6)%0A                     endif%0A%0A                  else%0A                     Failure_Code = (-5)%0A                  endif%0A%0A               else%0A                  Failure_Code = (-4)%0A               endif%0A%0A            else%0A               Failure_Code = (-3)%0A            endif%0A%0A         else%0A            Failure_Code = (-2)%0A         endif%0A%0A      else%0A         Failure_Code = (-1)%0A      endif%0A%0A      delete The_Object%0A%0A   endif%0A%0A# End Test 11%0A%0A#--------------------------------------------------------------------------%0A# Test 12%0A#--------------------------------------------------------------------------%0A%0A   if Test = 12 then%0A%0A      # This test shall prove that I_SIM allows root data types to be used for%0A      # User Defined Types%2C and in fact totally ignores data typing.%0A%0A      # Also note that the local data objects are UDT type%2C and reused by each%0A      # assingment. This will cause problems for WACA as first use for a local%0A      # object should defined it as being the same type as the attribute that%0A      # is being copied into it. Subsequent copies should cause grief.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Reals with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Reals with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Reals with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Real  = Plus_One%0A      The_Object1.Second_Real = Minus_Ten%0A      The_Object1.Third_Real  = Minus_Ten%0A      The_Object1.Fourth_Real = Plus_Max%0A      The_Object1.Fifth_Real  = Minus_Max%0A      The_Object1.Sixth_Real  = Minus_Max%0A%0A      The_Object2.First_Real  = Plus_One%0A      The_Object2.Second_Real = Minus_One%0A      The_Object2.Third_Real  = Minus_Ten%0A      The_Object2.Fourth_Real = Plus_One%0A      The_Object2.Fifth_Real  = Minus_One%0A      The_Object2.Sixth_Real  = Plus_Max%0A%0A      # 1.0 + 1.0 in range 1.0..10.0 result 2.0 inside range%0A      Local_Real1 = The_Object1.First_Real  %0A      Local_Real2 = The_Object2.First_Real%0A      Result_Real3 = Local_Real1 + Local_Real2%0A      Result_Object.First_Real  =  Result_Real3%0A%0A      # -10.0 - -1.0 in range -10.0 .. -1.0 result = -9.0 inside of range%0A      Local_Real4 = The_Object1.Second_Real  %0A      Local_Real5 = The_Object2.Second_Real%0A      Result_Real6 = Local_Real4 - Local_Real5%0A      Result_Object.Second_Real  =  Result_Real6%0A%0A      # -10.0 - -10.0 in range -10.0 .. +10.0 result = 0.0 inside range%0A      Local_Real7 = The_Object1.Third_Real  %0A      Local_Real8 = The_Object2.Third_Real%0A      Result_Real9 = Local_Real7 - Local_Real8%0A      Result_Object.Third_Real  =  Result_Real9%0A%0A      # 32767.0 - 1.0 in range 1.0 .. 32767.0 result 32766.0 inside of range%0A      Local_Real10 = The_Object1.Fourth_Real  %0A      Local_Real11 = The_Object2.Fourth_Real%0A      Result_Real12 = Local_Real10 - Local_Real11%0A      Result_Object.Fourth_Real  =  Result_Real12%0A%0A      # -32768.0 - -1.0 in range -32768.0 .. -1.0 result -32767.0 inside of range%0A      Local_Real13 = The_Object1.Fifth_Real  %0A      Local_Real14 = The_Object2.Fifth_Real%0A      Result_Real15 = Local_Real13 - Local_Real14%0A      Result_Object.Fifth_Real  =  Result_Real15%0A%0A      # -32768.0 + 32767.0 in range -32768.0 .. 32767.0 result -1.0 inside range%0A      Local_Real16 = The_Object1.Sixth_Real  %0A      Local_Real17 = The_Object2.Sixth_Real%0A      Result_Real18 = Local_Real16 + Local_Real17%0A      Result_Object.Sixth_Real  =  Result_Real18%0A%0A      # Non unique binary operands%0A      if Result_Real3  = Result_Object.First_Real  &\%0A         Result_Real6  = Result_Object.Second_Real &\%0A         Result_Real9  = Result_Object.Third_Real  &\%0A         Result_Real12 = Result_Object.Fourth_Real &\%0A         Result_Real15 = Result_Object.Fifth_Real  &\%0A         Result_Real18 = Result_Object.Sixth_Real then%0A%0A         Test_Has_Passed = TRUE%0A      else%0A         Failure_Code = -1%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 12%0A%0A#--------------------------------------------------------------------------%0A# Test 13%0A#--------------------------------------------------------------------------%0A%0A   if Test = 13 then%0A%0A      # This test proves that individual local data objects must be used for different data%0A      # types.%0A%0A      # This test is the same as test 12%2C with one important difference. The local%0A      # data objects are not reused%2C thus first use should specify them as %0A      # of the attribute's type%2C and no conflict should arise.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Reals with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Reals with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Reals with Unique_Identifier = Other_Id%0A%0A      The_Object1.First_Real  = Plus_One%0A      The_Object1.Second_Real = Minus_Ten%0A      The_Object1.Third_Real  = Minus_Ten%0A      The_Object1.Fourth_Real = Plus_Max%0A      The_Object1.Fifth_Real  = Minus_Max%0A      The_Object1.Sixth_Real  = Minus_Max%0A%0A      The_Object2.First_Real  = Plus_One%0A      The_Object2.Second_Real = Minus_One%0A      The_Object2.Third_Real  = Minus_Ten%0A      The_Object2.Fourth_Real = Plus_One%0A      The_Object2.Fifth_Real  = Minus_One%0A      The_Object2.Sixth_Real  = Plus_Max%0A  %0A      # 1.0 + 1.0 in range 1.0..10.0 result 2.0 inside range%0A      Local_Real1 = The_Object1.First_Real  %0A      Local_Real2 = The_Object2.First_Real%0A      Result_Real3 = Local_Real1 + Local_Real2%0A      Result_Object.First_Real  =  Result_Real3%0A%0A      # -10.0 - -1.0 in range -10.0 .. -1.0 result = -9.0 inside of range%0A      Local_Real4 = The_Object1.Second_Real  %0A      Local_Real5 = The_Object2.Second_Real%0A      Result_Real6 = Local_Real4 - Local_Real5%0A      Result_Object.Second_Real  =  Result_Real6%0A%0A      # -10.0 - -10.0 in range -10.0 .. +10.0 result = 0.0 inside range%0A      Local_Real7 = The_Object1.Third_Real  %0A      Local_Real8 = The_Object2.Third_Real%0A      Result_Real9 = Local_Real7 - Local_Real8%0A      Result_Object.Third_Real  =  Result_Real9%0A%0A      # 32767.0 - 1.0 in range 1.0 .. 32767.0 result 32766.0 inside of range%0A      Local_Real10 = The_Object1.Fourth_Real  %0A      Local_Real11 = The_Object2.Fourth_Real%0A      Result_Real12 = Local_Real10 - Local_Real11%0A      Result_Object.Fourth_Real  =  Result_Real12%0A%0A      # -32768.0 - -1.0 in range -32768.0 .. -1.0 result -32767.0 inside of range%0A      Local_Real13 = The_Object1.Fifth_Real  %0A      Local_Real14 = The_Object2.Fifth_Real%0A      Result_Real15 = Local_Real13 - Local_Real14%0A      Result_Object.Fifth_Real  =  Result_Real15%0A%0A      # -32768.0 + 32767.0 in range -32768.0 .. 32767.0 result -1.0 inside range%0A      Local_Real16 = The_Object1.Sixth_Real  %0A      Local_Real17 = The_Object2.Sixth_Real%0A      Result_Real18 = Local_Real16 + Local_Real17%0A      Result_Object.Sixth_Real  =  Result_Real18%0A%0A      # Unique result_real's and binary operands%0A      if Result_Real3 = Result_Object.First_Real  &\%0A         Result_Real6 = Result_Object.Second_Real &\%0A         Result_Real9 = Result_Object.Third_Real  &\%0A         Result_Real12 = Result_Object.Fourth_Real &\%0A         Result_Real15 = Result_Object.Fifth_Real  &\%0A         Result_Real18 = Result_Object.Sixth_Real then%0A%0A         Test_Has_Passed = TRUE%0A      else%0A         Failure_Code = -1%0A      endif%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 13%0A%0A#--------------------------------------------------------------------------%0A# Test 14%0A#--------------------------------------------------------------------------%0A%0A   if Test = 14 then%0A%0A      # This test proves that individual local data objects must be used for different data%0A      # types.%0A%0A      # Add max values to minimum values.%0A%0A      # This test shall cause some attributes to go out of range on assignment%0A      # to the results object attributes.%0A%0A      # It is unclear what is to happen about this. %0A%0A      # It highlights an important distinction between I-SIM and WACA. %0A      # UDT's ARE TOTALLY UNSUPPORTED IN I-SIM%2C and trying to test for them here%0A      # will give erroneous results.%0A%0A      Other_Id  = Test + 1%0A      Result_ID = Other_Id + 1%0A%0A      The_Object1 = create Object_With_Reals with Unique_Identifier = Test%0A      The_Object2 = create Object_With_Reals with Unique_Identifier = Other_Id%0A      Result_Object = create Object_With_Reals with Unique_Identifier = Other_Id%0A%0A   #   The_Object1.First_Real  = Plus_One%0A   #   The_Object1.Second_Real = Minus_Ten%0A   #   The_Object1.Third_Real  = Minus_Ten%0A   #   The_Object1.Fourth_Real = Plus_One%0A   #   The_Object1.Fifth_Real  = Minus_Max%0A   #   The_Object1.Sixth_Real  = Minus_Max%0A%0A   #   The_Object2.First_Real  = Plus_Ten%0A   #   The_Object2.Second_Real = Plus_One%0A   #   The_Object2.Third_Real  = Plus_Ten%0A   #   The_Object2.Fourth_Real = Plus_Max%0A   #   The_Object2.Fifth_Real  = Minus_One%0A   #   The_Object2.Sixth_Real  = Plus_Max%0A%0A   # 1.0 + 10.0  in range 1.0 .. 10.0 result 11.0 outside of range%0A   #   Local_Real1 = The_Object1.First_Real  %0A   #   Local_Real2 = The_Object2.First_Real%0A   #   Result_Real3 = Local_Real1 + Local_Real2%0A   #   Result_Object.First_Real  =  Result_Real3%0A%0A   # -10.0 - 1.0 in range -10.0 .. -1.0 result = -11.0 outside of range%0A   #   Local_Real4 = The_Object1.Second_Real  %0A   #   Local_Real5 = The_Object2.Second_Real%0A   #   Result_Real6 = Local_Real4 - Local_Real5%0A   #   Result_Object.Second_Real  =  Result_Real6%0A%0A   # -10.0 - 10.0 in range -10.0 .. 10.0 result  -20.0 outside of range%0A   #   Local_Real7 = The_Object1.Third_Real  %0A   #   Local_Real8 = The_Object2.Third_Real%0A   #   Result_Real9 = Local_Real7 - Local_Real8%0A   #   Result_Object.Third_Real  =  Result_Real9%0A%0A   # 1.0 + 32767.0 in range 1.0 .. 32767.0 result 32768.0 outside of range%0A   #   Local_Real10 = The_Object1.Fourth_Real  %0A   #   Local_Real11 = The_Object2.Fourth_Real%0A   #   Result_Real12 = Local_Real10 + Local_Real11%0A   #   Result_Object.Fourth_Real  =  Result_Real12%0A%0A   # -32768.00 + -1.0 in range -32768.0 .. 0.0 result -32769.0 outside of range%0A   #   Local_Real13 = The_Object1.Fifth_Real  %0A   #   Local_Real14= The_Object2.Fifth_Real%0A   #   Result_Real15 = Local_Real13 + Local_Real14%0A   #   Result_Object.Fifth_Real  =  Result_Real15%0A%0A   # -32768.0 - 32767.0  in range -32768.0 .. 32767.0 result -65535.0 outside range%0A   #   Local_Real16 = The_Object1.Sixth_Real  %0A   #   Local_Real17 = The_Object2.Sixth_Real%0A   #   Result_Real18 = Local_Real16 - Local_Real17%0A   #   Result_Object.Sixth_Real  =  Result_Real18%0A%0A   # Unique result_real's and binary operands%0A%0A   #   if Result_Real3  = Result_Object.First_Real  &\%0A   #      Result_Real6  = Result_Object.Second_Real &\%0A   #      Result_Real9  = Result_Object.Third_Real  &\%0A   #      Result_Real12 = Result_Object.Fourth_Real &\%0A   #      Result_Real15 = Result_Object.Fifth_Real  &\%0A   #      Result_Real18 = Result_Object.Sixth_Real then%0A%0A   #      Test_Has_Passed = TRUE%0A   #   else%0A   #      Failure_Code = -1%0A   #   endif%0A%0A      Failure_Code = 0%0A%0A      delete The_Object1%0A      delete The_Object2%0A%0A   endif%0A%0A# End Test 14%0A%0A#--------------------------------------------------------------------------%0A# Report the results.%0A#--------------------------------------------------------------------------%0A%0Aif Test_Has_Passed then%0A  %0A   if Result_Object = UNDEFINED then%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Failure_Code]%0A   else%0A      [] = RPT2:Test_Passed[Testing_For%2C Test%2C Failure_Code]%0A%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.First_Real]%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.Second_Real]%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.Third_Real]%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.Fourth_Real]%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.Fifth_Real]%0A      [] = RPT8:Test_Real_Passed[Testing_For%2C Test%2C Result_Object.Sixth_Real]%0A   endif%0A%0Aelse%0A%0A   if Failure_Code = 0 then%0A      [] = RPT4:Test_Unsupported[Test]%0A   else%0A      [] = RPT3:Test_Failed[Testing_For%2C Test%2C Failure_Code]%0A   endif%0A%0Aendif%0A%0Aif Result_Object != UNDEFINED then%0A   delete Result_Object%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
object,,,,,,,,
object,Report_Data,RD,4,,,,,
attribute,Report_Data_Unique_id,preferred,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Reported_Domain_Number,,,Report_Data_Unique_id,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
object,Test_Data,TD,5,,,,,
attribute,Testing_For_What,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,The_Test_Number,,,Testing_For_What,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
description, Object containg the test data.%0A,,,,,,,
object,,,,,,,,
pragma,version,,,,,,,
pragmaitem,6,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
domain,,,,,,,,
