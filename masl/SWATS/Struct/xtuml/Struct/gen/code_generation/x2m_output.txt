domain,Struct,Structures,,,,,,
object,Report_Data,,,,,,,
object,,,,,,,,
object,Structured_Object,,,,,,,
object,,,,,,,,
object,Test_Data,,,,,,,
object,,,,,,,,
type,Second_Simple_Structure_Type,private,,,,,,
structure,Second_Simple_Structure_Type,,,,,,,
member,SS_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,SS_Real,,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,SS_Text,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,SS_Boolean,,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,SS_Colour,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Very_Simple_Structure_Type,private,,,,,,
structure,Very_Simple_Structure_Type,,,,,,,
member,Basic_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Two_Structures_Type,private,,,,,,
structure,Two_Structures_Type,,,,,,,
member,First_Structure,,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Second_Structure,,,,,,,
typeref,Third_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Multiple_Structures_Type,private,,,,,,
structure,Multiple_Structures_Type,,,,,,,
member,Initial_Structure,,,,,,,
typeref,First_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Secondary_Structure,,,,,,,
typeref,Second_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Penultimate_Structure,,,,,,,
typeref,Third_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Buried_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Alternative_Colour_Type,private,,,,,,
enumeration,Alternative_Colour_Type,,,,,,,
enumerator,Red,,,,,,,
enumerator,,,,,,,,
enumerator,Pink,,,,,,,
enumerator,,,,,,,,
enumerator,Puce,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Different_Structure_Type,private,,,,,,
structure,Different_Structure_Type,,,,,,,
member,Alternative_Colour,,,,,,,
typeref,Alternative_Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Extra_Member,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Complex_UDT_Structure_Type,private,,,,,,
structure,Complex_UDT_Structure_Type,,,,,,,
member,A_Top_Integer,,,,,,,
typeref,UDT_Integer_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_Top_Real,,,,,,,
typeref,UDT_Real_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_UDT_Structure,,,,,,,
typeref,UDT_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Basic_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_Colour,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
description, This structure shall contain a structure%2C a couple of user %0A defined types and a simple integer base type.%0A The UDT data shall have the same name and type as those %0A defined in the contained structure.%0A,,,,,,,
type,,,,,,,,
type,UDT_Real_Type,private,real,,,,,
range,0.0,100.0,,,,,,
range,,,,,,,,
type,,,,,,,,
type,UDT_Integer_Type,private,integer,,,,,
range,0,100,,,,,,
range,,,,,,,,
type,,,,,,,,
type,UDT_Structure_Type,private,,,,,,
structure,UDT_Structure_Type,,,,,,,
member,An_Integer,,,,,,,
typeref,UDT_Integer_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_Real,,,,,,,
typeref,UDT_Real_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
description, This structure shall contain user defined types.%0A,,,,,,,
type,,,,,,,,
type,My_Second_Structure,public,,,,,,
structure,My_Second_Structure,,,,,,,
member,Int_Val,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Real_Val,,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,String_Val,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Col_Val,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,My_Simple_Structure,public,,,,,,
structure,My_Simple_Structure,,,,,,,
member,Int_Value,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Colour_Value,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Structure_and_IH_Type,public,,,,,,
structure,Structure_and_IH_Type,,,,,,,
member,A_Defined_IH,,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Third_Nested_Structure_Type,public,,,,,,
structure,Third_Nested_Structure_Type,,,,,,,
member,Third_Nested_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,The_Holy_Grail,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Second_Nested_Structure_Type,public,,,,,,
structure,Second_Nested_Structure_Type,,,,,,,
member,Third_Nested_Structure,,,,,,,
typeref,Third_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Third_Nested_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,First_Nested_Structure_Type,public,,,,,,
structure,First_Nested_Structure_Type,,,,,,,
member,Second_Nested_Structure,,,,,,,
typeref,Second_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,First_Nested_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Name_and_Type_Linked_Simple_Structure_Type,public,,,,,,
structure,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
member,An_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_Real,,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,Some_Text,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,A_Boolean,,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Type_Linked_Simple_Structure_Type,public,,,,,,
structure,Type_Linked_Simple_Structure_Type,,,,,,,
member,TLS_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,TLS_Real,,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,TLS_Text,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,TLS_Boolean,,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
type,Colour_Type,public,,,,,,
enumeration,Colour_Type,,,,,,,
enumerator,Red,,,,,,,
enumerator,,,,,,,,
enumerator,Green,,,,,,,
enumerator,,,,,,,,
enumerator,Blue,,,,,,,
enumerator,,,,,,,,
enumeration,,,,,,,,
type,,,,,,,,
type,Simple_Structure_Type,public,,,,,,
structure,Simple_Structure_Type,,,,,,,
member,S_Integer,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,S_Real,,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,S_Text,,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,S_Boolean,,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
member,S_Colour,,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
member,,,,,,,,
structure,,,,,,,,
type,,,,,,,,
routine,Struct,,private,Simple_Structure_Scenario,1,,,
codeblock,# Set up scenario test data.%0ATest_Has_Passed = FALSE%0A%0AMy_Test_Data = find-one Test_Data%0ATest = My_Test_Data.The_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - Report the number of User Defined Types used%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Reported No UDTs"%2C "Obtain No of UDTs Used"]%0A%0A   Reported_No_UDT = 0%0A   Expected_No_UDT = 0%0A%0A   $INLINE%0A      Reported_No_UDT = 20;%0A      fprintf(stderr%2C"Checking number of UDTs. Hardcoded to %25d\n"%2C Reported_No_UDT);%0A   $ENDINLINE%0A%0A   #$ADA_INLINE%0A      #with Ada.Text_IO;%0A      #%0A      #with Struct_Domain_Types;%0A      #Reported_No_UDT := Struct_Domain_Types.Types_And_Subtypes_Count;%0A   #$END_ADAINLINE%0A%0A   # This is the hardcoded expected number of user defined types constant.%0A   # If any more UDT's are defined for this domain%2C this counter MUST be set accordingly.%0A   # Failure to do this will cause this test to fail in an ADA run.%0A%0A   Expected_No_UDT = 20%0A%0A   if Reported_No_UDT = Expected_No_UDT then%0A      [] = RPT2:Test_Passed["Report No UDTs"%2C Test%2C Reported_No_UDT]%0A   else %0A      [] = RPT3:Test_Failed["Report No UDTs"%2C Test%2C Expected_No_UDT]%0A   endif%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 -  Setup Test Data%0A#           Basic 'APPEND' operation tests %0A#           This test shall prove that a set is created empty.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Simple Scenario"%2C "Create empty structure"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0117"]%0A%0A   {Empty_Set} is Simple_Structure_Type%0A%0A   Naught = countof {Empty_Set}%0A%0A   if Naught = 0 then %0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Naught]%0A   endif%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Add some data into the set.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Simple Scenario"%2C "Add first structure to set"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0117"]%0A%0A   A_First_Local_Colour  of Colour_Type = 'Red'%0A   A_Second_Local_Colour of Colour_Type = 'Blue'%0A%0A   A_First_Local_Number  = 100%0A   A_First_Local_Real    = 100.0%0A   A_First_Local_String  = "Hello Good Evening and Welcome"%0A   A_First_Local_Boolean = TRUE%0A%0A   append [A_First_Local_Number%2C A_First_Local_Real%2C A_First_Local_String%2C A_First_Local_Boolean%2C A_First_Local_Colour] to {Empty_Set}%0A%0A   One = countof {Empty_Set}%0A%0A   if One = 1 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C One]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C One]%0A   endif%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - Add some more data into the set.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Simple Scenario"%2C "Add second structure to set"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0117"]%0A%0A   A_Second_Local_Number  = 200%0A   A_Second_Local_Real    = 200.0%0A   A_Second_Local_String  = "Thankyou and Goodnight"%0A   A_Second_Local_Boolean = FALSE%0A%0A   append [A_Second_Local_Number%2C A_Second_Local_Real%2C A_Second_Local_String%2C A_Second_Local_Boolean%2C A_Second_Local_Colour] to {Empty_Set}%0A%0A   Two = countof {Empty_Set}%0A%0A   if Two = 2 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C Two]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Two]%0A   endif%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 -  Read the data back%0A#           The Queue is implemented as a FIFO%2C so read it back as such.%0A#           This test will need to change should this implementation ever%0A#           change. This test will fail if this happens.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A   %0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Simple Scenario"%2C "Read back structure from set"]%0A   Local_Test_Passed = FALSE%0A%0A   How_Many = countof {Empty_Set}%0A   if How_Many = 2 then%0A      Counter = 1%0A%0A      for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean%2C A_Read_Colour] in {Empty_Set} do%0A%0A         if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \%0A                            A_Read_Real    = A_First_Local_Real    and \%0A                            A_Read_String  = A_First_Local_String  and \%0A                            A_Read_Boolean = A_First_Local_Boolean and \%0A                            A_Read_Colour  = A_First_Local_Colour  then%0A%0A            Local_Test_Passed = TRUE%0A         else %0A%0A            if Counter = 2 and A_Read_Number     = A_Second_Local_Number  and \%0A                               A_Read_Real       = A_Second_Local_Real    and \%0A                               A_Read_String     = A_Second_Local_String  and \%0A                               A_Read_Boolean    = A_Second_Local_Boolean and \%0A                               A_Read_Colour     = A_Second_Local_Colour  and \%0A                               Local_Test_Passed = TRUE  then%0A%0A               [] = RPT2:Test_Passed["Simple Scenario"%2C Test%2C A_Read_Number]%0A            else%0A               [] = RPT3:Test_Failed["Simple Scenario"%2C Test%2C A_Read_Number]%0A            endif%0A%0A         endif%0A%0A         Counter = Counter + 1%0A%0A      endfor%0A%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C How_Many]%0A   endif%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - Read the data back again%0A#          Prove that reading a set of structures does not change it%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A      %0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Simple Scenario"%2C "Prove non-destructive read"]%0A%0A   Local_Test_Passed = FALSE%0A%0A   How_Many = countof {Empty_Set}%0A%0A   if How_Many = 2 then%0A      Counter = 1%0A%0A      for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean%2C A_Read_Colour] in {Empty_Set} do%0A%0A         if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \%0A                            A_Read_Real    = A_First_Local_Real    and \%0A                            A_Read_String  = A_First_Local_String  and \%0A                            A_Read_Boolean = A_First_Local_Boolean and \%0A                            A_Read_Colour  = A_First_Local_Colour  then%0A %0A            Local_Test_Passed = TRUE%0A%0A         else %0A%0A            if Counter = 2 and A_Read_Number     = A_Second_Local_Number  and \%0A                               A_Read_Real       = A_Second_Local_Real    and \%0A                               A_Read_String     = A_Second_Local_String  and \%0A                               A_Read_Boolean    = A_Second_Local_Boolean and \%0A                               A_Read_Colour     = A_Second_Local_Colour  and \%0A                               Local_Test_Passed = TRUE  then%0A%0A               [] = RPT2:Test_Passed["Scenario"%2C Test%2C A_Read_Number]%0A            else%0A               [] = RPT3:Test_Failed["Scenario"%2C Test%2C A_Read_Number]%0A            endif%0A%0A         endif%0A%0A         Counter = Counter + 1%0A%0A      endfor%0A%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C How_Many]%0A   endif%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test creates a new return list for each test%2C so the %0A#          structure is always empty when we start.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A   Termination_Condition = Test + 5%0A%0A   A_Real_Number = 1.0%0A   %0A   # Create a new structure object.%0A   {Returned_Simple_Structure_1} is Simple_Structure_Type%0A%0A   struct_1 = create Structured_Object with Reference_SO  = Test                    & \%0A                                            Some_Text     = "Construct a structure" & \%0A                                            An_Integer    = Test                    & \%0A                                            A_Real        = A_Real_Number           &\%0A                                            A_Boolean     = TRUE                    &\%0A                                            A_Colour      = 'Green'                 &\%0A                                            Current_State = 'Idle'%0A%0A%0A%0A   [{Returned_Simple_Structure_1}] = SO1:Create_Simple_Structure[Test%2C struct_1]%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A# Test 8%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   [] = SO2:Decode_Simple_Structure[Test%2C {Returned_Simple_Structure_1}%2C struct_1%2C FALSE]%0A%0A   delete struct_1%0A%0A# End Test 8%0A%0A#--------------------------------------------------------------------------%0A# Test 9 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test uses the same return parameter for all tests%2C so the %0A#          results are appended on to the old return structure.%0A#%0A#          This test will examine what happens when an emptied set is %0A#          reused.%0A#          The set will be emptied by the Decode_Simple_Structure service%2C %0A#          and then written to again by the next iteration of the %0A#          Create_Simple_Structure.%0A#%0A#          It is understood that for WACA 3.0.0 reading the final entry %0A#          from a set will cause that set to be deleted. Subsequent appends%0A#          to that set will cause a fatal crash.%0A#%0A#          This is no longer the case for subsequent issues. However%2C  the%0A#          test still has some relevance%2C as it proves that structures can %0A#          be partially read from%2C and then appended to again.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   Termination_Condition = Test + 10%0A%0A   A_Real_Number = 1.0%0A%0A   {Returned_Simple_Structure_2} is Simple_Structure_Type%0A%0A   loop%0A      # Create a couple of structured objects%0A      struct_2 = create Structured_Object with Reference_SO  = Test                    &\%0A                                               Some_Text     = "Construct a structure" &\%0A                                               An_Integer    = Test                    &\%0A                                               A_Real        = A_Real_Number           &\%0A                                               A_Boolean     = FALSE                   &\%0A                                               A_Colour      = 'Green'                 &\%0A                                               Current_State = 'Idle'%0A%0A      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test%0A%0A      # Create a new structure object each time%2C otherwise the same%0A      # structure will be appended to each iteration.%0A      [{Returned_Simple_Structure_2}] = SO1:Create_Simple_Structure[Test%2C a_structured_instance_2]%0A%0A      Test = Test + 1%0A%0A      [] = SO2:Decode_Simple_Structure[Test%2C {Returned_Simple_Structure_2}%2C a_structured_instance_2%2C TRUE]%0A%0A      # Delete the object now we've done with it.%0A      delete a_structured_instance_2%0A%0A      Test = Test + 1%0A%0A      breakif Test = Termination_Condition%0A%0A   endloop%0A%0A# End Test 9%0A%0A#--------------------------------------------------------------------------%0A# Test 10 - Define a test which passes a single structure to an instance %0A#           through a generated event.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A%0A   struct_3 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\ %0A                                            A_Colour      = 'Green'                     &\%0A                                            Current_State = 'Idle'%0A%0A   # Create a simple structure and pass it in to the instance Simple_F1%0A   {Simple_Object_Structure_3} is Simple_Structure_Type%0A%0A   append [struct_3.Reference_SO%2C \%0A          struct_3.A_Real%2C        \%0A          struct_3.Some_Text%2C     \%0A          struct_3.A_Boolean%2C     \%0A          struct_3.A_Colour ] to {Simple_Object_Structure_3}%0A%0A   generate SO1:Start_Simple(Test%2C {Simple_Object_Structure_3} ) to struct_3%0A%0A# End Test 10%0A%0A#--------------------------------------------------------------------------%0A# Test 11 - Perform the same test again%2C except this time use a set of %0A#           structures with more than one set in it.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   A_Real_Number = 1.0%0A%0A   struct_4 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\%0A                                            A_Colour      = 'Green'                     &\%0A                                            Current_State = 'Idle'%0A%0A   {Simple_Object_Structure_4} is Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 0%0A%0A   loop%0A      append [struct_4.An_Integer%2C \%0A              struct_4.A_Real%2C     \%0A              struct_4.Some_Text%2C  \%0A              struct_4.A_Boolean%2C  \%0A              struct_4.A_Colour] to {Simple_Object_Structure_4}%0A%0A      Counter = Counter + 1%0A%0A      breakif Counter = Termination_Condition%0A%0A   endloop%0A%0A   generate SO1:Start_Simple(Test%2C {Simple_Object_Structure_4} ) to struct_4%0A%0A# End Test 11%0A%0A#--------------------------------------------------------------------------%0A# Test 12 - Pass in the simple structure into a domain based synchronous %0A#           service.%0A#--------------------------------------------------------------------------%0A%0A   Test = Test + 1%0A%0A   struct_5 = create Structured_Object with Reference_SO  = Test                         &\%0A                                            Some_Text     = "Domain based synch service" &\%0A                                            An_Integer    = Test                         &\%0A                                            A_Real        = 2.0                          &\%0A                                            A_Boolean     = TRUE                         &\%0A                                            A_Colour      = 'Green'                      &\%0A                                            Current_State = 'Idle'%0A%0A   {Simple_Object_Structure_5} is Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 1%0A%0A   loop%0A      append [struct_5.An_Integer%2C \%0A              struct_5.A_Real%2C     \%0A              struct_5.Some_Text%2C  \%0A              struct_5.A_Boolean%2C  \%0A              struct_5.A_Colour] to {Simple_Object_Structure_5}%0A%0A      Counter = Counter + 1%0A%0A      breakif Termination_Condition = Counter%0A%0A   endloop%0A%0A   # Invoke domain based synch. service%0A   [] = Struct2::Decode_Simple_Structure[Test%2C {Simple_Object_Structure_5}%2C struct_5]%0A%0A   delete struct_5%0A%0A# End Test 12%0A%0A#--------------------------------------------------------------------------%0A%0ATest = Test + 1%0A%0AMy_Test_Data.The_Test_Number = Test%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,1,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Simple Structure Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Complex_Structure_Scenario,2,,,
codeblock,My_Test_Data = find-one Test_Data%0A%0ATest = My_Test_Data.The_Test_Number%0A%0AZero = 0%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Create empty structure"]%0A%0A   {Outer_Set} is Complex_UDT_Structure_Type%0A%0A   Nought = countof {Outer_Set}%0A%0A   if Nought = Zero then%0A      [] = RPT2:Test_Passed["Create empty structure"%2C Test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["Create empty structure"%2C Test%2C Nought]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 - Add some data into the set.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Add data into structure"]%0A%0A   local_integer       = 10%0A   local_real          = 10.0%0A   local_basic_integer = 101%0A%0A   local_colour of Colour_Type = 'Red'%0A%0A   {Inner_Set} is UDT_Structure_Type%0A%0A   append [local_integer%2C local_real] to {Inner_Set}%0A%0A   append [local_integer%2C local_real%2C {Inner_Set}%2C local_basic_integer%2C local_colour] to {Outer_Set}%0A%0A   number_in_inner_set = countof {Inner_Set}%0A   number_in_outer_set = countof {Outer_Set}%0A%0A   if number_in_inner_set = 1 then%0A%0A      if number_in_outer_set = 1 then %0A         [] = RPT2:Test_Passed["Add data into structure"%2C Test%2C 0]%0A      else%0A         [] = RPT3:Test_Failed["Add data into structure"%2C Test%2C number_in_outer_set]%0A      endif%0A%0A   else%0A      [] = RPT3:Test_Failed["Add data into structure"%2C Test%2C number_in_inner_set]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Add a second entry into both sets%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Add more data into inner and outer structures"]%0A%0A   local_integer       = 20%0A   local_real          = 20.0%0A   local_basic_integer = 201%0A%0A   local_colour of Colour_Type = 'Blue'%0A%0A   append [local_integer%2C local_real] to {Inner_Set}%0A   append [local_integer%2C local_real%2C {Inner_Set}%2C local_basic_integer%2C local_colour] to {Outer_Set}%0A%0A   number_in_inner_set = countof {Inner_Set}%0A   number_in_outer_set = countof {Outer_Set}%0A%0A   if number_in_inner_set = 2 then%0A  %0A      if number_in_outer_set = 2 then %0A         [] = RPT2:Test_Passed["Add more data into structure"%2C Test%2C 0]%0A      else%0A         [] = RPT3:Test_Failed["Add more data into structure"%2C Test%2C number_in_outer_set]%0A      endif%0A%0A   else%0A      [] = RPT3:Test_Failed["Add more data into structure"%2C Test%2C number_in_inner_set]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A#  Test 4 - Add a new inner set into position 3 of the outer set.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Add new inner structure into outer structure"]%0A%0A   local_integer       = 30%0A   local_real          = 30.0%0A   local_basic_integer = 301%0A   local_colour of Colour_Type = 'Green'%0A%0A   {New_Inner_Set} is UDT_Structure_Type%0A%0A   append [local_integer%2C local_real] to {New_Inner_Set}%0A   append [local_integer%2C local_real%2C {New_Inner_Set}%2C local_basic_integer%2C local_colour] to {Outer_Set}%0A%0A   number_in_inner_set = countof {New_Inner_Set}%0A   number_in_outer_set = countof {Outer_Set}%0A%0A   if number_in_inner_set = 1 then%0A%0A      if number_in_outer_set = 3 then %0A         [] = RPT2:Test_Passed["Add more data into structure"%2C Test%2C 0]%0A      else%0A         [] = RPT3:Test_Failed["Add more data into structure"%2C Test%2C number_in_outer_set]%0A      endif%0A%0A   else%0A      [] = RPT3:Test_Failed["Add more data into structure"%2C Test%2C number_in_inner_set]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - Decode all sets of structures%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Decode structures"]%0A%0A   {decoded_inner_structure} is UDT_Structure_Type%0A%0A   number_in_both_structures = 0%0A   total_value = 0%0A%0A   number_in_outer_set = countof {Outer_Set}%0A%0A   number_in_both_structures = number_in_outer_set%0A%0A   for [this_integer%2C this_real%2C {decoded_inner_structure}%2C this_basic_integer%2C this_colour] in {Outer_Set} do%0A      total_value               = total_value + this_integer%0A      number_in_inner_set       = countof {decoded_inner_structure}%0A      number_in_both_structures = number_in_inner_set + number_in_both_structures%0A%0A      for [this_inner_integer%2C this_inner_real] in {decoded_inner_structure} do%0A         total_value = total_value + this_inner_integer%0A      endfor%0A%0A   endfor%0A%0A   if total_value = 130 then%0A      [] = RPT2:Test_Passed["Decode structures"%2C Test%2C number_in_both_structures]%0A   else%0A      [] = RPT3:Test_Failed["Decode structures"%2C Test%2C number_in_both_structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - Since we are no longer labouring under the destructive read %0A#          restrictions%2C it would be prudent to check that all structures %0A#          are still current in all sets.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "And again"]%0A%0A   {empty_decoded_inner_structure} is UDT_Structure_Type%0A%0A   number_in_both_structures = 0%0A   total_value               = 0%0A   number_in_outer_set       = countof {Outer_Set}%0A   number_in_both_structures = number_in_outer_set%0A%0A   for [this_integer%2C this_real%2C {empty_decoded_inner_structure}%2C this_basic_integer%2C this_colour] in {Outer_Set} do%0A      total_value               = total_value + this_integer%0A      number_in_inner_set       = countof {empty_decoded_inner_structure}%0A      number_in_both_structures = number_in_inner_set + number_in_both_structures%0A%0A      for [this_inner_integer%2C this_inner_real] in {empty_decoded_inner_structure} do%0A         total_value = total_value + this_inner_integer%0A      endfor%0A%0A   endfor%0A%0A   if total_value = 130 then%0A      [] = RPT2:Test_Passed["And again"%2C Test%2C number_in_both_structures]%0A   else%0A      [] = RPT3:Test_Failed["And again"%2C Test%2C number_in_both_structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - Having established how sets of structures are contained in a set %0A#          of structures%2C examine how the data is held%2C deep or shallow %0A#          copy. To achieve this%2C the test shall add on entry the the inner %0A#          & outer sets to check how that addition has affected the other %0A#          sets in the outer set that point to it.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Deep or shallow copy"]%0A%0A   local_integer       = 40%0A   local_real          = 40.0%0A   local_basic_integer = 401%0A%0A   local_colour of Colour_Type = 'Red'%0A%0A   append [local_integer%2C local_real] to {Inner_Set}%0A%0A   append [local_integer%2C local_real%2C {Inner_Set}%2C local_basic_integer%2C local_colour] to {Outer_Set}%0A%0A   # Having added a third entry onto the inner and and a fourth to the outer set%2C %0A   # have a look to see if the earlier entries in the outer set point to the latest version %0A   # of the inner set%2C ie. outer_set(1).{inner_set} = inner_set(4). If this is the case then %0A   # we have a shallow copy%2C otherwise if outer_set(1).{inner_set] = inner_set(1) then we have a deep copy.%0A%0A   # A deep copy is what is required here.%0A   {fresh_decoded_inner_structure} is UDT_Structure_Type%0A%0A   A_Counter    = 0%0A   Passed_Count = 0%0A %0A   {fresh_decoded_inner_structure} is UDT_Structure_Type%0A%0A   for [this_integer%2C this_real%2C {fresh_decoded_inner_structure}%2C this_basic_integer%2C this_colour] in {Outer_Set} do%0A      A_Counter          = A_Counter + 1%0A      Number_In_This_Set = countof{fresh_decoded_inner_structure}%0A%0A      if A_Counter = 1 and Number_In_This_Set = 1 then%0A         Passed_Count = Passed_Count + 1        %0A      else%0A%0A         if A_Counter = 2 and Number_In_This_Set = 2 then%0A            Passed_Count = Passed_Count + 1        %0A         else%0A%0A            if A_Counter = 3 and Number_In_This_Set = 1 then%0A               Passed_Count = Passed_Count + 1        %0A            else%0A%0A               if A_Counter = 4 and Number_In_This_Set = 3 then%0A                  Passed_Count = Passed_Count + 1        %0A               endif%0A%0A            endif%0A%0A         endif%0A%0A      endif%0A%0A   endfor%0A%0A   number_in_outer_set = countof {Outer_Set}%0A%0A   # This test has proved that first structure of the outer set of structures contains the inner set(a)  %0A   # with 1 structure and that the second structure of the outer set contains the inner set(a) with two %0A   # structures%2C the third structure of the outer set contains a new inner set(b) with one structure and %0A   # finally%2C the fourth structure of the outer set contains the inner set (a) now with three structures.%0A   # Exactly as it was set up.%0A%0A   # A shallow copy would have shown that the first structure in the outer set had an %0A   # inner structure with three structures.%0A%0A   if Passed_Count = number_in_outer_set then%0A      [] = RPT2:Test_Passed["DEEP copy"%2C Test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["SHALLOW copy"%2C Test%2C Passed_Count]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A# Test 8 - Having proved that each outer set contains the requisite number %0A#          of inner sets%2C now show that the inner set is actually the inner%0A#          set we expected to see.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Compare contents of inner and outer structures"]%0A%0A   {another_fresh_decoded_inner_structure} is UDT_Structure_Type%0A%0A   A_Counter = 0%0A   Total_Number_Of_Inner_Structures = 0%0A%0A   Inner_Count  = 0%0A   Passed_Count = 0%0A%0A   for [this_integer%2C this_real%2C {another_fresh_decoded_inner_structure}%2C this_basic_integer%2C this_colour] in {Outer_Set} do%0A      Inner_Count = 0%0A      A_Counter   = A_Counter + 1%0A%0A      Number_In_This_Set = countof {another_fresh_decoded_inner_structure}%0A%0A      Total_Number_Of_Inner_Structures =Total_Number_Of_Inner_Structures + Number_In_This_Set%0A%0A      for [inner_integer%2C inner_real] in {another_fresh_decoded_inner_structure} do%0A         Inner_Count = Inner_Count + 1%0A%0A         if A_Counter = 1 and Number_In_This_Set = 1 then%0A%0A            if Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0) then%0A               Passed_Count = Passed_Count + 1        %0A            endif%0A%0A         else%0A%0A            if A_Counter = 2 and Number_In_This_Set = 2 then%0A%0A               if (Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0)) or \ %0A                  (Inner_Count = 2 and (inner_integer = 20 and inner_real = 20.0)) then%0A%0A                  Passed_Count = Passed_Count + 1        %0A %0A               endif%0A   %0A            else%0A%0A               if A_Counter = 3 and Number_In_This_Set = 1 then%0A%0A                  if Inner_Count = 1 and (inner_integer = 30 and inner_real = 30.0) then %0A                     Passed_Count = Passed_Count + 1        %0A                  endif%0A%0A               else%0A%0A                  if A_Counter = 4 and Number_In_This_Set = 3 then%0A%0A                     if (Inner_Count = 1 and (inner_integer = 10 and inner_real = 10.0)) or \ %0A                        (Inner_Count = 2 and (inner_integer = 20 and inner_real = 20.0)) or \%0A                        (Inner_Count = 3 and (inner_integer = 40 and inner_real = 40.0)) then%0A%0A                        Passed_Count = Passed_Count + 1        %0A                     endif%0A%0A                  endif%0A%0A               endif%0A%0A            endif%0A%0A         endif%0A%0A      endfor%0A%0A   endfor%0A%0A   if Passed_Count = Total_Number_Of_Inner_Structures then%0A      [] = RPT2:Test_Passed["DEEP copy"%2C Test%2C Total_Number_Of_Inner_Structures]%0A   else%0A      [] = RPT3:Test_Failed["SHALLOW copy"%2C Test%2C Passed_Count]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 8%0A%0A#--------------------------------------------------------------------------%0A# Test 9 - Show what happens when two outer structures point to the same %0A#          inner stucture.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Compare contents of outer structures"]%0A%0A   {First_Outer_Set}  is Complex_UDT_Structure_Type%0A   {Second_Outer_Set} is Complex_UDT_Structure_Type%0A   {Common_Inner_Set} is UDT_Structure_Type%0A%0A   local_integer       = 10%0A   local_real          = 10.0%0A   local_basic_integer = 101%0A   local_colour of Colour_Type = 'Red'%0A%0A   append [local_integer%2Clocal_real] to {Common_Inner_Set}%0A%0A   append [local_integer%2C local_real%2C {Common_Inner_Set}%2C local_basic_integer%2C local_colour] to {First_Outer_Set}%0A   append [local_integer%2C local_real%2C {Common_Inner_Set}%2C local_basic_integer%2C local_colour] to {Second_Outer_Set}%0A%0A   # Now add a new structure to the common inner set%0A   local_integer       = 20%0A   local_real          = 20.0%0A   local_basic_integer = 201%0A%0A   local_colour of Colour_Type = 'Blue'%0A%0A   append [local_integer%2Clocal_real] to {Common_Inner_Set}%0A%0A   # Add this new set of structures to the second outer set%2C but not the first.%0A   append [local_integer%2C local_real%2C {Common_Inner_Set}%2C local_basic_integer%2C local_colour] to {Second_Outer_Set}%0A%0A   # Now add a new structure to the inner set%0A   local_integer       = 30%0A   local_real          = 30.0%0A   local_basic_integer = 301%0A%0A   local_colour of Colour_Type = 'Green'%0A%0A   append [local_integer%2Clocal_real] to {Common_Inner_Set}%0A%0A   # Add this new set of structures to the first outer set%2C but not the second%0A   append [local_integer%2C local_real%2C {Common_Inner_Set}%2C local_basic_integer%2C local_colour] to {First_Outer_Set}%0A%0A   # So%2C what we have is two outer sets of structures%2C both with a common first inner set%2C but different second inner%0A   # structures.%0A%0A   {First_Inner_Set}  is UDT_Structure_Type%0A%0A   First_Total_Count = 0%0A%0A   for [this_integer%2C this_real%2C {First_Inner_Set}%2C this_basic_integer%2C this_colour] in {First_Outer_Set} do%0A      First_Total_Count = First_Total_Count + this_integer%0A%0A      for [inner_integer%2C inner_real] in {First_Inner_Set} do%0A         First_Total_Count = First_Total_Count + inner_integer%0A      endfor%0A%0A   endfor%0A%0A   {Second_Inner_Set} is UDT_Structure_Type%0A%0A   Second_Total_Count = 0%0A  %0A   for [this_integer%2C this_real%2C {Second_Inner_Set}%2C this_basic_integer%2C this_colour] in {Second_Outer_Set} do%0A      Second_Total_Count = Second_Total_Count + this_integer%0A%0A      for [inner_integer%2C inner_real] in {Second_Inner_Set} do%0A         Second_Total_Count = Second_Total_Count + inner_integer%0A      endfor%0A%0A   endfor%0A%0A   if First_Total_Count = 110 and Second_Total_Count = 70 then%0A      [] = RPT2:Test_Passed["DEEP copy"%2C Test%2C Total_Number_Of_Inner_Structures]%0A   else%0A      [] = RPT3:Test_Failed["SHALLOW copy"%2C Test%2C First_Total_Count]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 9%0A%0A#--------------------------------------------------------------------------%0A# Test 10%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Complex Scenario"%2C "Append an empty structure"]%0A%0A   # Append an empty simple structures to a outer structure.%0A   {Empty_Structure} is UDT_Structure_Type%0A   {Outer_Structure} is Complex_UDT_Structure_Type%0A%0A   append [local_integer%2C local_real%2C {Empty_Structure}%2C local_basic_integer%2C local_colour] to {Outer_Structure}%0A%0A   Number_In_Outer_Structures   = countof {Outer_Structure}%0A   Number_In_Empty_Structure    = countof {Empty_Structure}%0A%0A   if Number_In_Outer_Structures   =1 & Number_In_Empty_Structure    = 0 then%0A      [] = RPT2:Test_Passed["Append empty structure to complex structure"%2C Test%2C Number_In_Empty_Structure]%0A   else%0A      [] = RPT3:Test_Failed["Append empty structure to complex structure"%2C Test%2C Number_In_Empty_Structure]%0A   endif%0A%0A#--------------------------------------------------------------------------%0A%0ATest = Test + 1%0A%0AMy_Test_Data.The_Test_Number = Test%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,2,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Complex Structure Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Simple_Type_Linked_Structure_Scenario,3,,,
codeblock,#--------------------------------------------------------------------------%0A# Setup Test Data%0A#%0A# TYPE LINKED Simple Structures%0A#--------------------------------------------------------------------------%0A%0AMy_Test_Data = find-one Test_Data%0ATest = My_Test_Data.The_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - Basic 'APPEND' operation tests%0A#          This test shall prove that a set is created empty.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Create empty TL structure"]%0A%0A   {TL_Empty_Set} is Type_Linked_Simple_Structure_Type%0A%0A   Naught = countof {TL_Empty_Set}%0A%0A   if Naught = 0 then %0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Naught]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 - Add some data into the set%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Add first TL structure to set"]%0A%0A   A_First_Local_Number  = 100%0A   A_First_Local_Real    = 100.0%0A   A_First_Local_String  = "Hello Good Evening and Welcome"%0A   A_First_Local_Boolean = TRUE%0A%0A   append [A_First_Local_Number%2C A_First_Local_Real%2C A_First_Local_String%2C A_First_Local_Boolean] to {TL_Empty_Set}%0A%0A   One = countof {TL_Empty_Set}%0A%0A   if One = 1 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C One]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C One]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End  Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Add some more data into the set.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Add second TL structure to set"]%0A%0A   A_Second_Local_Number  = 200%0A   A_Second_Local_Real    = 200.0%0A   A_Second_Local_String  = "Thankyou and Goodnight"%0A   A_Second_Local_Boolean = FALSE%0A%0A   append [A_Second_Local_Number%2C A_Second_Local_Real%2C A_Second_Local_String%2C A_Second_Local_Boolean] to {TL_Empty_Set}%0A%0A   Two = countof {TL_Empty_Set}%0A%0A   if Two = 2 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C Two]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Two]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - Read the data back%0A#          The Queue is implemented as a FIFO%2C so read it back as such.%0A#          This test will need to change should this implementation ever%0A#          change. This test will fail if this happens.%0A#--------------------------------------------------------------------------%0A   %0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Read back TL structure from set"]%0A%0A   Counter = 1%0A%0A   Local_Test_Passed = FALSE%0A%0A   for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean] in {TL_Empty_Set} do%0A%0A      if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \%0A                         A_Read_Real    = A_First_Local_Real    and \%0A                         A_Read_String  = A_First_Local_String  and \%0A                         A_Read_Boolean = A_First_Local_Boolean then%0A%0A        Local_Test_Passed = TRUE%0A%0A      else%0A%0A         if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \%0A                            A_Read_Real    = A_Second_Local_Real    and \%0A                            A_Read_String  = A_Second_Local_String  and \%0A                            A_Read_Boolean = A_Second_Local_Boolean and \%0A                            Local_Test_Passed = TRUE then%0A%0A            [] = RPT2:Test_Passed["Scenario"%2C Test%2C A_Read_Number]%0A         else%0A            [] = RPT3:Test_Failed["Scenario"%2C Test%2C A_Read_Number]%0A         endif%0A%0A      endif%0A%0A      Counter = Counter + 1%0A%0A   endfor%0A%0A   Test = Test + 1%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - Read the data back again%0A#          Prove that reading a set of structures does not change it%0A#--------------------------------------------------------------------------%0A      %0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Prove non-destructive read"]%0A%0A   Local_Test_Passed = FALSE%0A%0A   How_Many = countof {TL_Empty_Set}%0A%0A   if How_Many = 2 then%0A      Counter = 1%0A%0A      for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean] in {TL_Empty_Set} do%0A%0A         if Counter = 1 and A_Read_Number  = A_First_Local_Number and \%0A                            A_Read_Real    = A_First_Local_Real   and \%0A                            A_Read_String  = A_First_Local_String and \%0A                            A_Read_Boolean = A_First_Local_Boolean then%0A%0A            Local_Test_Passed = TRUE%0A%0A         else %0A%0A            if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \%0A                               A_Read_Real    = A_Second_Local_Real    and \%0A                               A_Read_String  = A_Second_Local_String  and \%0A                               A_Read_Boolean = A_Second_Local_Boolean and \%0A                               Local_Test_Passed = TRUE then%0A%0A               [] = RPT2:Test_Passed["Scenario"%2C Test%2C A_Read_Number]%0A            else%0A               [] = RPT3:Test_Failed["Scenario"%2C Test%2C A_Read_Number]%0A            endif%0A%0A         endif%0A%0A         Counter = Counter + 1%0A%0A      endfor%0A%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C How_Many]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test creates a new return list for each test%2C so the %0A#          structure is always empty when we start.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A   %0A   # Create a new structure object.%0A   {TL_Returned_Simple_Structure_1} is Type_Linked_Simple_Structure_Type%0A%0A   struct_1 = create Structured_Object with Reference_SO  = Test                    &\%0A                                            Some_Text     = "Construct a structure" &\%0A                                            An_Integer    = Test                    &\%0A                                            A_Real        = A_Real_Number           &\%0A                                            A_Boolean     = TRUE                    &\%0A                                            A_Colour      = 'Red'                   &\%0A                                            Current_State = 'Idle'%0A%0A   [{TL_Returned_Simple_Structure_1}] = SO5:Create_Simple_TL_Structure[Test%2C struct_1]%0A%0A   Test = Test + 1%0A%0A   [] = SO6:Decode_Simple_TL_Structure[Test%2C {TL_Returned_Simple_Structure_1}%2C struct_1%2C FALSE]%0A%0A   delete struct_1%0A%0A   Test = Test + 1%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test uses the same return parameter for all tests%2C so the %0A#          results are appended on to the old return structure.%0A#%0A#          This test will examine what happens when an emptied set is %0A#          reused.%0A#          The set will be emptied by the Decode_Simple_Structure service%2C %0A#          and then written to again by the next iteration of the %0A#          Create_Simple_Structure.%0A#%0A#          It is understood that reading the final entry from a set will %0A#          cause that set to be deleted. Subsequent appends to that set will%0A#          cause a fatal crash.%0A#%0A#          To avoid this%2C ensure that the final entry of a set is never read %0A#          from.%0A#          This will prove that a set may be written to again after it has %0A#          been partially read from.%0A#--------------------------------------------------------------------------%0A%0A   Termination_Condition = Test + 10%0A%0A   A_Real_Number = 1.0%0A%0A   {TL_Returned_Simple_Structure_2} is Type_Linked_Simple_Structure_Type%0A%0A   loop%0A      # Create a couple of structured objects%0A      struct_2 = create Structured_Object with Reference_SO  = Test                    &\%0A                                               Some_Text     = "Construct a structure" &\%0A                                               An_Integer    = Test                    &\%0A                                               A_Real        = A_Real_Number           &\%0A                                               A_Boolean     = FALSE                   &\%0A                                               A_Colour      = 'Red'                   &\%0A                                               Current_State = 'Idle'%0A%0A      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test%0A%0A      # Create a new structure object each time%2C otherwise the same%0A      # structure will be appended to each iteration.%0A      [{TL_Returned_Simple_Structure_2}] = SO5:Create_Simple_TL_Structure[Test%2C a_structured_instance_2]%0A%0A      Test = Test + 1%0A%0A      [] = SO6:Decode_Simple_TL_Structure[Test%2C\%0A                                          {TL_Returned_Simple_Structure_2}%2C\%0A                                          a_structured_instance_2%2C \%0A                                          TRUE]%0A%0A      # Delete the object now we've done with it.%0A      delete a_structured_instance_2%0A%0A      Test = Test + 1%0A%0A      breakif Test = Termination_Condition%0A%0A   endloop%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A# Test 8 - Define a test which passes a single structure to an instance %0A#          through a generated event.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A%0A   struct_3 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\%0A                                            A_Colour      = 'Red'                       &\%0A                                            Current_State = 'Idle'%0A%0A   # Create a simple structure and pass it in to the instance Simple_F1%0A   {TL_Simple_Object_Structure_3} is Type_Linked_Simple_Structure_Type%0A%0A   append [struct_3.Reference_SO%2C \%0A           struct_3.A_Real%2C       \%0A           struct_3.Some_Text%2C    \%0A           struct_3.A_Boolean] to {TL_Simple_Object_Structure_3}%0A%0A   generate SO5:Start_TL_Simple(Test%2C {TL_Simple_Object_Structure_3} ) to struct_3%0A%0A   Test = Test + 1%0A%0A# End Test 8%0A%0A#--------------------------------------------------------------------------%0A# Test 9 - Perform the same test again%2C except this time use a set of %0A#          structures with more than one set in it.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A%0A   struct_4 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\%0A                                            A_Colour      = 'Red'                       &\%0A                                            Current_State = 'Idle'%0A%0A   {TL_Simple_Object_Structure_4} is Type_Linked_Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 0%0A%0A   loop%0A      append [struct_4.An_Integer%2C \%0A              struct_4.A_Real%2C     \%0A              struct_4.Some_Text%2C  \%0A              struct_4.A_Boolean] to {TL_Simple_Object_Structure_4}%0A%0A      Counter = Counter + 1%0A%0A      breakif Counter = Termination_Condition%0A%0A   endloop%0A%0A   generate SO5:Start_TL_Simple(Test%2C {TL_Simple_Object_Structure_4} ) to struct_4%0A%0A   Test = Test + 1%0A%0A# End Test 9%0A%0A#--------------------------------------------------------------------------#%0A# Test 10 - Pass in the simple structure into a domain based synchronous service.%0A#--------------------------------------------------------------------------%0A%0A   struct_5 = create Structured_Object with Reference_SO  = Test                         &\%0A                                            Some_Text     = "Domain based synch service" &\%0A                                            An_Integer    = Test                         &\%0A                                            A_Real        = 2.0                          &\%0A                                            A_Boolean     = TRUE                         &\%0A                                            A_Colour      = 'Red'                        &\%0A                                            Current_State = 'Idle'%0A%0A   {TL_Simple_Object_Structure_5} is Type_Linked_Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 1%0A%0A   loop%0A      append [struct_5.An_Integer%2C \%0A              struct_5.A_Real%2C     \%0A              struct_5.Some_Text%2C  \%0A              struct_5.A_Boolean] to {TL_Simple_Object_Structure_5}%0A%0A      Counter = Counter + 1%0A%0A      breakif Termination_Condition = Counter%0A%0A   endloop%0A%0A   # Invoke domain based synch. service%0A   [] = Struct4::Decode_Simple_TL_Structure[Test%2C {TL_Simple_Object_Structure_5}%2C struct_5]%0A%0A   delete struct_5%0A%0A# End Test 10%0A%0A#--------------------------------------------------------------------------%0A%0ATest = Test + 1%0A%0AMy_Test_Data.The_Test_Number = Test,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,3,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Simple Type Linked Structure Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Simple_Name_and_Type_Linked_Scenario,4,,,
codeblock,#--------------------------------------------------------------------------%0A# Setup Test Data%0A#%0A# TYPE LINKED Simple Structures%0A#--------------------------------------------------------------------------%0A%0AMy_Test_Data = find-one Test_Data%0A%0ATest = My_Test_Data.The_Test_Number%0A%0A#-------------------------------------------------------------------------- %0A# Test 1 - Basic 'APPEND' operation tests%0A#          This test shall prove that a set is created empty.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Create empty NTL structure"]%0A%0A   {NTL_Empty_Set} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   Naught = countof {NTL_Empty_Set}%0A%0A   if Naught = 0 then %0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Naught]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 - Add some data into the set.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Add first NTL structure to set"]%0A%0A   A_First_Local_Number  = 100%0A   A_First_Local_Real    = 100.0%0A   A_First_Local_String  = "Hello Good Evening and Welcome"%0A   A_First_Local_Boolean = TRUE%0A%0A   append [A_First_Local_Number%2C A_First_Local_Real%2C A_First_Local_String%2C A_First_Local_Boolean] to {NTL_Empty_Set}%0A%0A   One = countof {NTL_Empty_Set}%0A%0A   if One = 1 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C One]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C One]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Add some more data into the set.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Add second NTL structure to set"]%0A%0A   A_Second_Local_Number  = 200%0A   A_Second_Local_Real    = 200.0%0A   A_Second_Local_String  = "Thankyou and Goodnight"%0A   A_Second_Local_Boolean = FALSE%0A%0A   append [A_Second_Local_Number%2C A_Second_Local_Real%2C A_Second_Local_String%2C A_Second_Local_Boolean] to {NTL_Empty_Set}%0A%0A   Two = countof {NTL_Empty_Set}%0A%0A   if Two = 2 then%0A      [] = RPT2:Test_Passed["Scenario"%2C Test%2C Two]%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C Two]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - Read the data back%0A#          The Queue is implemented as a FIFO%2C so read it back as such.%0A#          This test will need to change should this implementation ever%0A#          change. This test will fail if this happens.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Read back TL structure from set"]%0A%0A   Counter = 1%0A   Local_Test_Passed = FALSE%0A%0A   for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean] in {NTL_Empty_Set} do%0A%0A      if Counter = 1 and A_Read_Number  = A_First_Local_Number  and \%0A                         A_Read_Real    = A_First_Local_Real    and \%0A                         A_Read_String  = A_First_Local_String  and \%0A                         A_Read_Boolean = A_First_Local_Boolean then%0A%0A         Local_Test_Passed = TRUE%0A      else%0A%0A         if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \%0A                            A_Read_Real    = A_Second_Local_Real    and \%0A                            A_Read_String  = A_Second_Local_String  and \%0A                            A_Read_Boolean = A_Second_Local_Boolean and \%0A                            Local_Test_Passed = TRUE then%0A%0A            [] = RPT2:Test_Passed["Scenario"%2C Test%2C A_Read_Number]%0A         else%0A            [] = RPT3:Test_Failed["Scenario"%2C Test%2C A_Read_Number]%0A         endif%0A%0A      endif%0A%0A      Counter = Counter + 1%0A%0A   endfor%0A%0A   Test = Test + 1%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - Read the data back again%0A#          Prove that reading a set of structures does not change it%0A#--------------------------------------------------------------------------%0A      %0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Scenario"%2C "Prove non-destructive read"]%0A%0A   Local_Test_Passed = FALSE%0A%0A   How_Many = countof {NTL_Empty_Set}%0A%0A   if How_Many = 2 then%0A      Counter = 1%0A%0A      for [A_Read_Number%2C A_Read_Real%2C A_Read_String%2C A_Read_Boolean] in {NTL_Empty_Set} do%0A%0A         if Counter = 1 and A_Read_Number  = A_First_Local_Number and \%0A                            A_Read_Real    = A_First_Local_Real   and \%0A                            A_Read_String  = A_First_Local_String and \%0A                            A_Read_Boolean = A_First_Local_Boolean then%0A%0A            Local_Test_Passed = TRUE%0A         else %0A%0A            if Counter = 2 and A_Read_Number  = A_Second_Local_Number  and \%0A                               A_Read_Real    = A_Second_Local_Real    and \%0A                               A_Read_String  = A_Second_Local_String  and \%0A                               A_Read_Boolean = A_Second_Local_Boolean and \%0A                               Local_Test_Passed = TRUE then%0A%0A               [] = RPT2:Test_Passed["Scenario"%2C Test%2C A_Read_Number]%0A            else%0A               [] = RPT3:Test_Failed["Scenario"%2C Test%2C A_Read_Number]%0A            endif%0A%0A         endif%0A%0A         Counter = Counter + 1%0A%0A      endfor%0A%0A   else%0A      [] = RPT3:Test_Failed["Scenario"%2C Test%2C How_Many]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test creates a new return list for each test%2C so the %0A#          structure is always empty when we start.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A   %0A   # Create a new structure object.%0A   {NTL_Returned_Simple_Structure_1} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   struct_1 = create Structured_Object with Reference_SO  = Test                    &\%0A                                            Some_Text     = "Construct a structure" &\%0A                                            An_Integer    = Test                    &\%0A                                            A_Real        = A_Real_Number           &\%0A                                            A_Boolean     = TRUE                    &\%0A                                            A_Colour      = 'Blue'                  &\%0A                                            Current_State = 'Idle'%0A%0A   [{NTL_Returned_Simple_Structure_1}] = SO7:Create_Simple_NTL_Structure[Test%2C struct_1]%0A%0A   Test = Test + 1%0A%0A   [] = SO8:Decode_Simple_NTL_Structure[Test%2C {NTL_Returned_Simple_Structure_1}%2C struct_1%2C FALSE]%0A%0A   delete struct_1%0A%0A   Test = Test + 1%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - Call object based synch service to create a data structure%2C %0A#          return it and then confirm that it was created correctly.%0A#          This test uses the same return parameter for all tests%2C so the %0A#          results are appended on to the old return structure.%0A#%0A#          This test will examine what happens when an emptied set is %0A#          reused.%0A#          The set will be emptied by the Decode_Simple_Structure service%2C %0A#          and then written to again by the next iteration of the %0A#          Create_Simple_Structure.%0A#%0A#          It is understood that reading the final entry from a set will %0A#          cause that set to be deleted. Subsequent appends to that set will %0A#          cause a fatal crash.%0A#%0A#          To avoid this%2C ensure that the final entry of a set is never read%0A#          from.%0A#          This will prove that a set may be written to again after it has %0A#          been partially read from.%0A#--------------------------------------------------------------------------%0A%0A   Termination_Condition = Test + 10%0A%0A   A_Real_Number = 1.0%0A%0A   {NTL_Returned_Simple_Structure_2} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   loop%0A%0A      # Create a couple of structured objects%0A      struct_2 = create Structured_Object with Reference_SO  = Test                    &\%0A                                               Some_Text     = "Construct a structure" &\%0A                                               An_Integer    = Test                    &\%0A                                               A_Real        = A_Real_Number           &\%0A                                               A_Boolean     = FALSE                   &\%0A                                               A_Colour      = 'Blue'                  &\%0A                                               Current_State = 'Idle'%0A%0A      a_structured_instance_2 = find-one Structured_Object where Reference_SO = Test%0A%0A      # Create a new structure object each time%2C otherwise the same%0A      # structure will be appended to each iteration.%0A%0A      [{NTL_Returned_Simple_Structure_2}] = SO7:Create_Simple_NTL_Structure[Test%2C a_structured_instance_2]%0A%0A      Test = Test + 1%0A  %0A      [] = SO8:Decode_Simple_NTL_Structure[Test%2C \%0A                                           {NTL_Returned_Simple_Structure_2}%2C\%0A                                           a_structured_instance_2%2C \%0A                                           TRUE]%0A%0A      # Delete the object now we've done with it.%0A      delete a_structured_instance_2%0A%0A      Test = Test + 1%0A%0A      breakif Test = Termination_Condition%0A%0A   endloop%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A# Test 8 - Define a test which passes a single structure to an instance %0A#          through a generated event.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A%0A   struct_3 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\%0A                                            A_Colour      = 'Blue'                      &\%0A                                            Current_State = 'Idle'%0A%0A   # Create a simple structure and pass it in to the instance Simple_F1%0A   {NTL_Simple_Object_Structure_3} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   append [struct_3.Reference_SO%2C \%0A           struct_3.A_Real%2C       \%0A           struct_3.Some_Text%2C    \ %0A           struct_3.A_Boolean] to {NTL_Simple_Object_Structure_3}%0A%0A   generate SO6:Start_NTL_Simple(Test%2C {NTL_Simple_Object_Structure_3} ) to struct_3%0A%0A   Test = Test + 1%0A%0A# End Test 8%0A%0A#--------------------------------------------------------------------------%0A# Test 9 - Perform the same test again%2C except this time use a set of %0A#          structures with more than one set in it.%0A#--------------------------------------------------------------------------%0A%0A   A_Real_Number = 1.0%0A%0A   struct_4 = create Structured_Object with Reference_SO  = Test                        &\%0A                                            Some_Text     = "generate simple structure" &\%0A                                            An_Integer    = Test                        &\%0A                                            A_Real        = A_Real_Number               &\%0A                                            A_Boolean     = FALSE                       &\%0A                                            A_Colour      = 'Blue'                      &\ %0A                                            Current_State = 'Idle'%0A%0A   {NTL_Simple_Object_Structure_4} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 0%0A%0A   loop%0A      append [struct_4.An_Integer%2C \%0A              struct_4.A_Real%2C     \%0A              struct_4.Some_Text%2C   \%0A              struct_4.A_Boolean] to {NTL_Simple_Object_Structure_4}%0A%0A      Counter = Counter + 1%0A%0A      breakif Counter = Termination_Condition%0A%0A   endloop%0A%0A   generate SO6:Start_NTL_Simple(Test%2C {NTL_Simple_Object_Structure_4} ) to struct_4%0A%0A   Test = Test + 1%0A%0A# End Test 9%0A%0A#--------------------------------------------------------------------------%0A# Test 10 - Pass in the simple structure into a domain based synchronous %0A#           service.%0A#--------------------------------------------------------------------------%0A%0A   struct_5 = create Structured_Object with Reference_SO  = Test                         &\%0A                                            Some_Text     = "Domain based synch service" &\%0A                                            An_Integer    = Test                         &\%0A                                            A_Real        = 2.0                          &\%0A                                            A_Boolean     = TRUE                         &\%0A                                            A_Colour      = 'Blue'                       &\%0A                                            Current_State = 'Idle'%0A%0A   {NTL_Simple_Object_Structure_5} is Name_and_Type_Linked_Simple_Structure_Type%0A%0A   Termination_Condition = 10%0A   Counter = 1%0A%0A   loop%0A      append [struct_5.An_Integer%2C \%0A              struct_5.A_Real%2C     \%0A              struct_5.Some_Text%2C  \%0A              struct_5.A_Boolean] to {NTL_Simple_Object_Structure_5}%0A%0A      Counter = Counter + 1%0A%0A      breakif Termination_Condition = Counter%0A%0A   endloop%0A%0A   # Invoke domain based synch. service%0A   [] = Struct6::Decode_Simple_NTL_Structure[Test%2C\%0A                                            {NTL_Simple_Object_Structure_5}%2C           \%0A                                            struct_5] %0A%0A   delete struct_5%0A%0A# End Test 10%0A%0A#--------------------------------------------------------------------------%0A%0ATest = Test + 1%0A%0AMy_Test_Data.The_Test_Number = Test,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,4,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Simple Name and Type Linked Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Nested_Structure_Scenario,5,,,
codeblock,My_Test_Data = find-one Test_Data%0A%0Alocal_test_number = My_Test_Data.The_Test_Number%0A%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - Create a nested stucture containing another structure which in %0A#          turn contains another structure. Pass it into a domain based %0A#          synchronous service for decoding.%0A#--------------------------------------------------------------------------%0A%0A   Zero  = 0%0A   One   = 1%0A   Two   = 2%0A   Three = 3%0A%0A   The_Colour of Colour_Type = 'Blue'%0A%0A   {The_Third_Structure}  is Third_Nested_Structure_Type%0A   {The_Second_Structure} is Second_Nested_Structure_Type%0A   {The_First_Structure}  is First_Nested_Structure_Type%0A%0A   append [Three%2C The_Colour]           to {The_Third_Structure}%0A   append [{The_Third_Structure}%2C Two]  to {The_Second_Structure}%0A   append [{The_Second_Structure}%2C One] to {The_First_Structure}%0A%0A   [] = Struct7::Decode_Three_Level_Nested_Structure [local_test_number%2C     \%0A                                                      {The_First_Structure}%2C \%0A                                                      {The_Second_Structure}%2C\%0A                                                      {The_Third_Structure}%2C \%0A                                                      One%2C One%2C              \%0A                                                      Two%2C One%2C              \%0A                                                      Three%2C One%2C The_Colour]%0A%0A   local_test_number = local_test_number + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 %0A#--------------------------------------------------------------------------%0A%0A   {The_Next_First_Structure}  is First_Nested_Structure_Type%0A   {The_Next_Second_Structure} is Second_Nested_Structure_Type%0A   {The_Next_Third_Structure}  is Third_Nested_Structure_Type%0A%0A   termination_condition = Three%0A%0A   loop%0A      append [Three%2C The_Colour] to {The_Next_Third_Structure}%0A      termination_condition = termination_condition - 1%0A      breakif termination_condition = Zero%0A   endloop%0A%0A   termination_condition = Three%0A%0A   loop%0A      append [{The_Next_Third_Structure}%2C Two] to {The_Next_Second_Structure}%0A      termination_condition = termination_condition - 1%0A      breakif termination_condition = Zero%0A   endloop%0A%0A   termination_condition = Three%0A%0A   loop%0A      append [ {The_Next_Second_Structure}%2C One] to {The_Next_First_Structure}%0A      termination_condition = termination_condition - 1%0A      breakif termination_condition = Zero%0A   endloop%0A%0A   [] = Struct7::Decode_Three_Level_Nested_Structure [local_test_number%2C          \%0A                                                      {The_Next_First_Structure}%2C \%0A                                                      {The_Next_Second_Structure}%2C\%0A                                                      {The_Next_Third_Structure}%2C \%0A                                                      One%2C Three%2C                 \%0A                                                      Two%2C Three%2C                 \%0A                                                      Three%2C Three%2C The_Colour]%0A%0A   local_test_number = local_test_number + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - create a Beasty test. This is where a primitve component of the%0A#          structure is defined%2C and the sub (nested) structure component %0A#          is null.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[local_test_number%2C"1241-0000-01-1212"%2C "Structures"%2C "Complex nested structures"%2C "contains a null structure"]%0A%0A   {This_First_Structure} is First_Nested_Structure_Type%0A   {This_Second_Structure} is Second_Nested_Structure_Type%0A%0A   append [ {This_Second_Structure} %2C One] to {This_First_Structure}%0A%0A   how_many = countof {This_First_Structure} %0A%0A   if how_many = 1 then%0A      [] = RPT2:Test_Passed["null structure"%2C local_test_number%2C 0]%0A   else%0A      [] = RPT3:Test_Failed["null_structure"%2C local_test_number%2C how_many]%0A   endif%0A%0A   local_test_number = local_test_number + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A%0AMy_Test_Data.The_Test_Number = local_test_number%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,5,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Nested Structure Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Start_Structures_Tests,6,,,
codeblock,My_Test_Data = create Test_Data with The_Test_Number = 1%0A[] = Struct8::Create_Report_Data[],,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,6,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Start_Structures_Tests%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Finish_Structures_Tests,7,,,
codeblock,[] = Struct9::Delete_Report_Data[]%0A%0Amy_test_data = find-one Test_Data%0A%0Aif my_test_data != UNDEFINED then%0A%0A   delete my_test_data%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,7,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Finish_Structures_Tests%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Multiple_Structures_In_A_Structure_Scenario,8,,,
codeblock,#--------------------------------------------------------------------------%0A# This scenario contains tests that are unsupported by WACA at version 3.0.1%0A# Introduced for version 4.0.0 and onwards.%0A#--------------------------------------------------------------------------%0A%0Amy_test = find-one Test_Data%0ATest    = my_test.The_Test_Number%0AZero     = 0%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - %0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "Two populated structures in one"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   # Append populated simple structures to a multiple structure.%0A   {Two_Structures}               is Two_Structures_Type%0A   {Two_Simple_Structure}         is Simple_Structure_Type%0A   {Two_Another_Simple_Structure} is Third_Nested_Structure_Type%0A%0A   this_int     = 100%0A   this_real    = 200.0%0A   this_text    = "Bag of bytes"%0A   this_boolean = TRUE%0A%0A   this_colour of Colour_Type = 'Blue'%0A%0A   append [this_int%2C this_real%2C this_text%2C this_boolean%2C this_colour] to {Two_Simple_Structure}%0A   append [this_int%2C this_colour]                                     to {Two_Another_Simple_Structure}%0A   append [{Two_Simple_Structure}%2C {Two_Another_Simple_Structure}]    to {Two_Structures}%0A%0A   Number_In_Two_Structures   = countof {Two_Structures}%0A   Number_In_First_Structure  = countof {Two_Simple_Structure}%0A   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}%0A%0A   if Number_In_Two_Structures   = 1      &\%0A      Number_In_First_Structure  = 1      &\%0A      Number_In_Second_Structure = 1 then%0A%0A      [] = RPT2:Test_Passed["Two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   else%0A      [] = RPT3:Test_Failed["Two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "Another two populated structures in one"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   # Append populated simple structures to a multiple structure.%0A   append [this_int%2C this_real%2C this_text%2C this_boolean%2C this_colour] to {Two_Simple_Structure}%0A   append [this_int%2C this_colour]                                     to {Two_Another_Simple_Structure}%0A   append [{Two_Simple_Structure}%2C {Two_Another_Simple_Structure}]    to {Two_Structures}%0A%0A   Number_In_Two_Structures   = countof {Two_Structures}%0A   Number_In_First_Structure  = countof {Two_Simple_Structure}%0A   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}%0A%0A%0A   if Number_In_Two_Structures = 2 & Number_In_First_Structure = 2 & Number_In_Second_Structure = 2 then%0A      [] = RPT2:Test_Passed["Another two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   else%0A      [] = RPT3:Test_Failed["Another two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "Third two populated structures in one"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   # Append populated simple structures to a multiple structure.%0A   append [this_int%2C this_real%2C this_text%2C this_boolean%2C this_colour] to {Two_Simple_Structure}%0A   append [this_int%2C this_colour]                                     to {Two_Another_Simple_Structure}%0A   append [{Two_Simple_Structure}%2C {Two_Another_Simple_Structure}]    to {Two_Structures}%0A%0A   Number_In_Two_Structures   = countof {Two_Structures}%0A   Number_In_First_Structure  = countof {Two_Simple_Structure}%0A   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}%0A%0A   if Number_In_Two_Structures   = 3 &\%0A      Number_In_First_Structure  = 3  &\%0A      Number_In_Second_Structure = 3 then%0A%0A      [] = RPT2:Test_Passed["Third two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   else%0A      [] = RPT3:Test_Failed["Third two populated sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - Decode appended populated simple structures from multiple structure.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "Decode Two structures in one"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   Final_Result                 = 0%0A   First_Countof                = 0%0A   Second_Countof               = 0%0A   How_Many_In_First_Structure  = 0%0A   How_Many_In_Second_Structure = 0%0A%0A   for [{Decode_First}%2C {Decode_Second}] in {Two_Structures} do%0A      How_Many_In_First_Structure  = countof {Decode_First}%0A      How_Many_In_Second_Structure = countof {Decode_Second}%0A%0A      First_Countof  = First_Countof  + How_Many_In_First_Structure%0A      Second_Countof = Second_Countof + How_Many_In_Second_Structure%0A   endfor%0A%0A   Number_In_Overall_Structure   = countof {Two_Structures}%0A%0A   Final_Result = First_Countof + Second_Countof + Number_In_Overall_Structure%0A%0A   if First_Countof = 6 & Second_Countof = 6 & Number_In_Overall_Structure = 3 then%0A      [] = RPT2:Test_Passed["Decode Two structures in one"%2C Test%2C Final_Result]%0A   else%0A      [] = RPT3:Test_Failed["Decode Two structures in one"%2C Test%2C Final_Result]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - Complex multiple structure%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "Multiple populated sets in 2nd structure"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   an_integer = 1%0A%0A   alternative_colour of Alternative_Colour_Type = 'Red'%0A   normal_colour of Colour_Type = 'Red'%0A%0A   {multiple_structure}       is Multiple_Structures_Type%0A   {local_first_structure}    is First_Nested_Structure_Type%0A   {local_second_structure}   is Second_Nested_Structure_Type%0A   {local_third_structure}    is Third_Nested_Structure_Type%0A   {different_colours}        is Different_Structure_Type%0A%0A   append [alternative_colour%2C Zero]                                                                 to {different_colours}%0A   append [an_integer%2C normal_colour]                                                                to {local_third_structure}%0A   append [{local_third_structure}%2C an_integer]                                                      to {local_second_structure}%0A   append [{local_second_structure}%2C an_integer]                                                     to {local_first_structure}%0A   append [ {local_first_structure}%2C {local_second_structure}%2C {local_third_structure}%2C an_integer ] to {multiple_structure}%0A%0A%0A   Number_In_Multiple_Structure = countof {multiple_structure}%0A   Number_In_First_Structure    = countof {local_first_structure}%0A   Number_In_Second_Structure   = countof {local_second_structure}%0A   Number_In_Third_Structure    = countof {local_third_structure}%0A%0A%0A   if Number_In_Multiple_Structure = 1 &\%0A      Number_In_First_Structure    = 1 &\%0A      Number_In_Third_Structure    = 1 &\%0A      Number_In_Second_Structure   = 1 then%0A %0A      [] = RPT2:Test_Passed["Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A%0A   else%0A      [] = RPT3:Test_Failed["Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A      [] = RPT5:Test_Text[Number_In_First_Structure%2C "First"]%0A      [] = RPT5:Test_Text[Number_In_Second_Structure%2C "Second"]%0A      [] = RPT5:Test_Text[Number_In_Third_Structure%2C "Third"]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 5%0A%0A#--------------------------------------------------------------------------%0A# Test 6 - Complex multiple structure%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "2nd Multiple populated sets in 2nd structure"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   an_integer = 2%0A%0A   append [alternative_colour%2C Zero]             to {different_colours}%0A   append [an_integer%2C normal_colour]            to {local_third_structure}%0A   append [{local_third_structure}%2C an_integer]  to {local_second_structure}%0A   append [{local_second_structure}%2C an_integer] to {local_first_structure}%0A%0A   append [ {local_first_structure}%2C {local_second_structure}%2C {local_third_structure}%2C an_integer ] to {multiple_structure}%0A%0A   Number_In_Multiple_Structure = countof {multiple_structure}%0A   Number_In_First_Structure    = countof {local_first_structure}%0A   Number_In_Second_Structure   = countof {local_second_structure}%0A   Number_In_Third_Structure    = countof {local_third_structure}%0A%0A   if Number_In_Multiple_Structure = 2 &\ %0A      Number_In_First_Structure    = 2 &\%0A      Number_In_Third_Structure    = 2 &\%0A      Number_In_Second_Structure   = 2 then%0A %0A      [] = RPT2:Test_Passed["2nd Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A   else%0A      [] = RPT3:Test_Failed["2nd Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A      [] = RPT5:Test_Text[Number_In_First_Structure%2C "First"]%0A      [] = RPT5:Test_Text[Number_In_Second_Structure%2C "Second"]%0A      [] = RPT5:Test_Text[Number_In_Third_Structure%2C "Third"]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 6%0A%0A#--------------------------------------------------------------------------%0A# Test 7 - Complex multiple structure%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Multiple Structures Scenario"%2C "3rd Multiple populated sets in 2nd structure"]%0A   [] = RPT8:Specify_Requid[Test%2C "1101-0000-01-0121"]%0A%0A   an_integer = 3%0A%0A   append [alternative_colour%2C Zero]             to {different_colours}%0A   append [an_integer%2C normal_colour]            to {local_third_structure}%0A   append [{local_third_structure}%2C an_integer]  to {local_second_structure}%0A   append [{local_second_structure}%2C an_integer] to {local_first_structure}%0A%0A   append [ {local_first_structure}%2C {local_second_structure}%2C {local_third_structure}%2C an_integer ] to {multiple_structure}%0A%0A%0A   Number_In_Multiple_Structure = countof {multiple_structure}%0A   Number_In_First_Structure    = countof {local_first_structure}%0A   Number_In_Second_Structure   = countof {local_second_structure}%0A   Number_In_Third_Structure    = countof {local_third_structure}%0A%0A   if Number_In_Multiple_Structure = 3 &\%0A      Number_In_First_Structure    = 3 &\%0A      Number_In_Third_Structure    = 3 &\%0A      Number_In_Second_Structure   = 3 then%0A %0A      [] = RPT2:Test_Passed["3rd Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A   else%0A      [] = RPT3:Test_Failed["3rd Multiple populated sets in 2nd structure"%2C Test%2C Number_In_Multiple_Structure]%0A%0A      [] = RPT5:Test_Text[Number_In_First_Structure%2C "First"]%0A      [] = RPT5:Test_Text[Number_In_Second_Structure%2C "Second"]%0A      [] = RPT5:Test_Text[Number_In_Third_Structure%2C "Third"]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 7%0A%0A#--------------------------------------------------------------------------%0A%0Amy_test.The_Test_Number = Test,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,8,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Multiple_Structures_In_A_Structure_Scenario%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Empty_Structures_Test,9,,,
codeblock,my_test = find-one Test_Data%0A%0ATest = my_test.The_Test_Number%0A%0A[Environment] = ET1:Env_String[]%0A%0A#--------------------------------------------------------------------------%0A# Test 1 %0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Empty Sets Scenario"%2C "Append one empty structures in one"]%0A%0A   # Append one empty simple structure to a parent structure.%0A   {Parent_Structure} is Complex_UDT_Structure_Type%0A   {Child_Structure} is UDT_Structure_Type%0A%0A   one   = 1%0A   two   = 2.0%0A   three = 3%0A%0A   This_Blue of Colour_Type = 'Blue'%0A%0A   append [ one%2C two%2C  {Child_Structure}%2C three%2C This_Blue ] to {Parent_Structure}%0A   %0A   Number_In_Child_Structure   = countof {Child_Structure}%0A   Number_In_Parent_Structure  = countof {Parent_Structure}%0A%0A   if Number_In_Parent_Structure = 1 & Number_In_Child_Structure  = 0 then%0A      [] = RPT2:Test_Passed["One empty sets in 1 structure"%2C Test%2C Number_In_Parent_Structure]%0A   else%0A      [] = RPT3:Test_Failed["One empty sets in 1 structure"%2C Test%2C Number_In_Parent_Structure]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Empty Sets Scenario"%2C "Two empty structures in one"]%0A%0A   # Append two empty simple structures to a multiple structure.%0A   {Two_Structures}               is Two_Structures_Type%0A   {Two_Simple_Structure}         is Simple_Structure_Type%0A   {Two_Another_Simple_Structure} is Third_Nested_Structure_Type%0A   %0A   append [{Two_Simple_Structure}%2C {Two_Another_Simple_Structure}] to {Two_Structures}%0A%0A   Number_In_Two_Structures   = countof {Two_Structures}%0A   Number_In_First_Structure  = countof {Two_Simple_Structure}%0A   Number_In_Second_Structure = countof {Two_Another_Simple_Structure}%0A%0A   if Number_In_Two_Structures   = 1 &\%0A      Number_In_First_Structure  = 0 &\%0A      Number_In_Second_Structure = 0 then%0A%0A      [] = RPT2:Test_Passed["Two empty sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   else%0A      [] = RPT3:Test_Failed["Two empty sets in 1 structure"%2C Test%2C Number_In_Two_Structures]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Complex multiple structure%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Empty Sets Scenario"%2C "Multiple empty sets in 1 structure"]%0A%0A   {multiple_structure}     is Multiple_Structures_Type%0A   {local_first_structure}  is First_Nested_Structure_Type%0A   {local_second_structure} is Second_Nested_Structure_Type%0A   {local_third_structure}  is Third_Nested_Structure_Type%0A   {different_colours}      is Different_Structure_Type%0A%0A   append [ {local_first_structure}%2C {local_second_structure}%2C {local_third_structure} ] to {multiple_structure}%0A%0A   Number_in_Multiple_Structure = countof {multiple_structure}%0A%0A   if Number_in_Multiple_Structure = 1 then%0A      [] = RPT2:Test_Passed["Multiple empty sets in 1 structure"%2C Test%2C Number_in_Multiple_Structure]%0A   else%0A      [] = RPT3:Test_Failed["Multiple empty sets in 1 structure"%2C Test%2C Number_in_Multiple_Structure]%0A   endif%0A%0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A%0Amy_test.The_Test_Number = Test,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,9,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Empty_Structures_Test%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Test_IH_In_Structures,10,,,
codeblock,my_test = find-one Test_Data%0A%0A[Environment] = ET1:Env_String[]%0A%0ATest_Number = my_test.The_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - First test in the sequence.%0A#          Create a Structured Object and append it to a structure.%0A#--------------------------------------------------------------------------%0A%0A   Primary_SO = create unique Structured_Object with An_Integer    = Test_Number &\%0A                                                     A_Real        = 1.0         &\%0A                                                     Some_Text     = "No text"   &\%0A                                                     A_Boolean     = TRUE        &\%0A                                                     A_Colour      = 'Red'       &\%0A                                                     Current_State = 'Idle'%0A%0A   # Take a copy of the preferred attribute for later use.%0A   Local_Copy_Of_IH_Identifer = Primary_SO.Reference_SO%0A%0A   {The_First_Structure} is Structure_and_IH_Type%0A%0A   append [Primary_SO] to {The_First_Structure}%0A%0A   [] = Struct1::Receive_Structure_IH [Test_Number%2C {The_First_Structure}%2C 1%2C \%0A                                       Primary_SO.Reference_SO%2C "Single instance in structure"]%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2 - Do the same test again%2C on the same data to prove that it has %0A#          not been corrupted and/or modified. Use the previously stored %0A#          value to compare against.%0A#--------------------------------------------------------------------------%0A%0A   [] = Struct1::Receive_Structure_IH [Test_Number%2C {The_First_Structure}%2C 1%2C \%0A                                       Local_Copy_Of_IH_Identifer%2C "Second bite at Single instance in structure"]%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Create a second Structured Object and append it to a structure.%0A#--------------------------------------------------------------------------%0A%0A   Secondary_SO = create unique Structured_Object with An_Integer    = Test_Number &\%0A                                                       A_Real        = 2.0         &\%0A                                                       Some_Text     = "No text"   &\%0A                                                       A_Boolean     = TRUE        &\%0A                                                       A_Colour      = 'Red'       &\%0A                                                       Current_State = 'Idle'%0A%0A   # Take a copy of the preferred attribute for later use.%0A   Local_Copy_Of_IH_Identifer = Secondary_SO.Reference_SO%0A%0A   append [Secondary_SO] to {The_First_Structure}%0A%0A   [] = Struct1::Receive_Structure_IH [Test_Number%2C {The_First_Structure}%2C 2%2C \%0A                                       Secondary_SO.Reference_SO%2C "Second instance in structure"]%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A# Test 4 - Do the same test again%2C on the same data to prove that it has %0A#          not been corrupted and/or modified. Use the previously stored %0A#          value to compare against.%0A#--------------------------------------------------------------------------%0A%0A   [] = Struct1::Receive_Structure_IH [Test_Number%2C {The_First_Structure}%2C 2%2C \%0A                                       Local_Copy_Of_IH_Identifer%2C "Second bite at Second instance in structure"]%0A%0A# End Test 4%0A%0A#--------------------------------------------------------------------------%0A# Test 5 - Send an empty structure to the target function. This may be %0A#          required as a target function could return a non-empty structure%0A#--------------------------------------------------------------------------%0A%0A#Test_Number = Test_Number + 1%0A%0A# UNSUPPORTED %0A%0A%0A# Clear up%2C but delete {The_First_Structure} operation is not implemented in ASL.%0A# So%2C create a new structure over the old one.%0A%0A# This test ensures that redeclaring the structure clears it out completely.%0A%0A# {The_First_Structure} is Structure_and_IH_Type%0A%0A# {Returned_Structure}  is Structure_and_IH_Type%0A%0A# [{Returned_Structure}] = Struct3::Receive_Empty_Structure_IH [Test_Number%2C {The_First_Structure}%2C \%0A#    Primary_SO%2C "Pass in empty structure%2C return full"]%0A%0A#--------------------------------------------------------------------------%0A%0A# Using the return from the previous test%2C check to see that the return parameter has been%0A# created and silled out as expected.%0A%0A# UNSUPPORTED due to previous test%0A%0A#Test_Number = Test_Number + 1%0A%0A#[] = Struct1::Receive_Structure_IH [Test_Number%2C {Returned_Structure}%2C 1%2C \%0A#   Primary_SO.Reference_SO%2C "Previously returned structure is ok"]%0A%0A%0A%0A#--------------------------------------------------------------------------%0A# Series of tests%0A#--------------------------------------------------------------------------%0A%0A   bean_counter = 1%0A%0A   {Next_Structure} is Structure_and_IH_Type%0A%0A   loop%0A      Test_Number = Test_Number + 1%0A%0A      Next_SO = create unique Structured_Object with An_Integer    = Test_Number &\%0A                                                     A_Real        = 1.0         &\%0A                                                     Some_Text     = "No text"   &\%0A                                                     A_Boolean     = TRUE        &\%0A                                                     A_Colour      = 'Red'       &\%0A                                                     Current_State = 'Idle'%0A%0A      append [Next_SO] to {Next_Structure}%0A%0A      [] = Struct1::Receive_Structure_IH [Test_Number%2C {Next_Structure}%2C bean_counter%2C Next_SO.Reference_SO%2C "Many instances in structure"]%0A %0A      bean_counter = bean_counter + 1%0A%0A      breakif bean_counter > 5%0A%0A   endloop%0A%0A#--------------------------------------------------------------------------%0A# Next series of tests. Let's see what happens when the structure is deleted after it is appended.%0A# This test will make sure that the data is copied into the target structure%2C and not just passed%0A# by reference.%0A#--------------------------------------------------------------------------%0A%0A   bean_counter = 1%0A%0A   {Delete_Structure} is Structure_and_IH_Type%0A%0A   loop%0A      Test_Number = Test_Number + 1%0A%0A      # Resuse the Next_SO data name.%0A      Next_SO = create unique Structured_Object with An_Integer    = Test_Number &\%0A                                                     A_Real        = 1.0         &\%0A                                                     Some_Text     = "No text"   &\%0A                                                     A_Boolean     = TRUE        &\%0A                                                     A_Colour      = 'Red'       &\%0A                                                     Current_State = 'Idle'%0A%0A      SO_ID = Next_SO.Reference_SO%0A%0A      append [Next_SO] to {Delete_Structure}%0A%0A      [] = Struct1::Receive_Structure_IH [Test_Number%2C {Delete_Structure}%2C bean_counter%2C SO_ID%2C "Structure fully copied"]%0A%0A      # Deleting the instance object before it is passed into the function call as a component of the structure%0A      # causes I-Sim grief. It appears that a shallow copy is taken%2C ie. it is passed by reference. To prove this%0A      # delete the instance object and then do the same test again.%0A      if Environment = "WACA" then%0A         delete Next_SO%0A      endif%0A%0A      Test_Number = Test_Number + 1%0A%0A      [] = Struct1::Receive_Structure_IH [Test_Number%2C {Delete_Structure}%2C bean_counter%2C SO_ID%2C "Structure fully copied"]%0A %0A      bean_counter = bean_counter + 1%0A%0A      breakif bean_counter > 5%0A%0A   endloop%0A%0A   # Delete structure is not supported by ASL or WACA%2C although it will compile.%0A   # Run_Time crash in I-SIM awaits the unwary.%0A   # delete {Next_Structure}%0A%0A%0A#--------------------------------------------------------------------------%0A# Tidy up and finish this sequence of tests.%0A#--------------------------------------------------------------------------%0A%0ATest_Number = Test_Number + 1%0A%0Amy_test.The_Test_Number = Test_Number,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,10,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Test_IH_In_Structures%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Structures_are_Cleared,11,,,
codeblock,#--------------------------------------------------------------------------%0A# These series of tests ensure that although there is no way of deleting a %0A# structure once it is in existance%2C we can at least reduce the structure %0A# back to being empty when necessary.%0A#--------------------------------------------------------------------------%0A%0Amy_test = find-one Test_Data%0A%0ATest_Number = my_test.The_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1 - Create a Structure and append to it.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test_Number%2C "1241-0000-01-1212"%2C "Structures"%2C "Structures cleared"%2C "Structures memory usage test"]%0A%0A   {Simple_Destructive_Structure} is Simple_Structure_Type%0A%0A   # Blunder round a loop ten thousand times%2C adding fifty structures into %0A   # the set of structure. This should give an indication of whether WACA %0A   # returns the freed space back to the heap after the structure is %0A   # redeclared.%0A%0A   # NB. Use the Performance Meter in the Windows NT task manager%0A   #     to monitor memory usage.%0A%0A   Number_Of_Iterations = 10000%0A   Number_Of_Appends = 50%0A%0A   # Test data section%0A   The_Integer = Test_Number%0A   The_Real    = 0.99%0A   The_Text    = "How big?"%0A   The_Boolean = FALSE%0A%0A   The_Colour of Colour_Type = 'Blue'%0A%0A   Little_Bean_Counter = 0%0A   Big_Bean_Counter    = 0%0A%0A   Test_Has_Failed = FALSE%0A%0A   loop%0A      Little_Bean_Counter = 0%0A%0A      loop%0A         append [The_Integer%2C The_Real%2C The_Text%2C The_Boolean%2C The_Colour] to {Simple_Destructive_Structure}%0A%0A         breakif Little_Bean_Counter = Number_Of_Appends%0A  %0A         Little_Bean_Counter = Little_Bean_Counter + 1%0A      endloop%0A%0A      # Redeclare the structure%2C effectively removing the fully defined%0A      # structure and resetting it to zero size.%0A      {Simple_Destructive_Structure} is Simple_Structure_Type%0A%0A      # If the structure has not been cleaned up%2C bail out. There is%0A      # no point continuing.%0A%0A      How_Many_Now = countof {Simple_Destructive_Structure}%0A      if How_Many_Now != 0 then%0A         Test_Has_Failed = TRUE%0A         break%0A      endif%0A%0A      breakif Big_Bean_Counter = Number_Of_Iterations%0A%0A      Big_Bean_Counter = Big_Bean_Counter + 1%0A%0A   endloop%0A%0A   if Test_Has_Failed then%0A      [] = RPT3:Test_Failed["Structures not cleared up"%2C Test_Number%2C Big_Bean_Counter]%0A   else%0A      Result_Value = Little_Bean_Counter * Big_Bean_Counter%0A      [] = RPT2:Test_Passed["Structures cleared"%2C Test_Number%2C Result_Value]%0A   endif%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test_Number%2C "1241-0000-01-1212"%2C "Structures"%2C "Structures cleared"%2C "Reuse Structure name with different type"]%0A%0A   Little_Bean_Counter = 0%0A   Big_Bean_Counter    = 1%0A%0A   {Simple_Destructive_Structure} is Simple_Structure_Type%0A%0A   # Blunder round a loop two times%2C adding two hundred and fifty thousand%0A   # structures into the set of structure. This should give an indication of %0A   # whether WACA returns the freed space back to the heap after the structure %0A   # is redeclared.%0A%0A   # NB. Use the Performance Meter in the Windows NT task manager%0A   #     to monitor memory usage.%0A%0A   Number_Of_Iterations = 2%0A   Number_Of_Appends = 250000%0A%0A   # Test data section%0A   The_Integer = Test_Number%0A   The_Real    = 0.99%0A   The_Text    = "Different structure type"%0A   The_Boolean = FALSE%0A%0A   The_Colour of Colour_Type = 'Blue'%0A%0A   Test_Has_Failed = FALSE%0A%0A   loop%0A      Little_Bean_Counter = 0%0A%0A      loop%0A         append [The_Integer%2C The_Real%2C The_Text%2C The_Boolean%2C The_Colour] to {Simple_Destructive_Structure}%0A    %0A         breakif Little_Bean_Counter = Number_Of_Appends%0A%0A         Little_Bean_Counter = Little_Bean_Counter + 1%0A      endloop%0A%0A      # Redeclare the structure%2C effectively removing the fully defined%0A      # structure and resetting it to zero size. This test differs from %0A      # the previous in that the type of the structure has changed%2C and %0A      # the number of appends and iterations have swapped values!%0A      # Due to a WACA limitation (and ADA95 if we are honest) the reuse%0A      # of a named definition for a different type is precluded.%0A%0A      {Simple_Destructive_Structure} is Simple_Structure_Type%0A%0A      # If the structure has not been cleaned up%2C bail out. There is%0A      # no point continuing.%0A%0A      How_Many_Now = countof {Simple_Destructive_Structure}%0A      if How_Many_Now != 0 then%0A         Test_Has_Failed = TRUE%0A         break%0A      endif%0A%0A      breakif Big_Bean_Counter = Number_Of_Iterations%0A%0A      Big_Bean_Counter = Big_Bean_Counter + 1%0A%0A   endloop%0A%0A   if Test_Has_Failed then%0A      [] = RPT3:Test_Failed["Structures not cleared up"%2C Test_Number%2C Big_Bean_Counter]%0A   else%0A      Result_Value = Little_Bean_Counter * Big_Bean_Counter%0A      [] = RPT2:Test_Passed["Structures cleared"%2C Test_Number%2C Result_Value]%0A   endif%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3 - Now try a similar test on a structure containing an instance %0A#          handle.%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test_Number%2C "1241-0000-01-1216"%2C "Structures"%2C "Structures cleared"%2C "Structures with IH memory usage test"]%0A%0A   {Structure_And_IH_Destructive_Structure} is Structure_and_IH_Type%0A%0A   # Blunder round a loop ten thousand times%2C adding fifty%0A   # structures into the set of structure. This should give an %0A   # indication of whether WACA returns the freed space back%0A   # to the heap after the structure is redeclared.%0A%0A   # NB. Use the Performance Meter in the Windows NT task manager%0A   #     to monitor memory usage.%0A%0A   Number_Of_Iterations = 10000%0A   Number_Of_Appends = 50%0A%0A   A_Structured_Object_IH = create unique Structured_Object with An_Integer    = Test_Number &\%0A                                                                 A_Real        = 99.99       &\%0A                                                                 Some_Text     = "Some Text" &\%0A                                                                 A_Boolean     = FALSE       &\%0A                                                                 A_Colour      = 'Green'     &\%0A                                                                 Current_State ='Idle'%0A%0A   # Test data section%0A%0A   Little_Bean_Counter = 0%0A   Big_Bean_Counter    = 0%0A%0A   Test_Has_Failed = FALSE%0A%0A   loop%0A      Little_Bean_Counter = 0%0A%0A      loop%0A         append [A_Structured_Object_IH] to {Structure_And_IH_Destructive_Structure}%0A%0A         breakif Little_Bean_Counter = Number_Of_Appends%0A%0A         Little_Bean_Counter = Little_Bean_Counter + 1%0A      endloop%0A%0A      # Redeclare the structure%2C effectively removing the fully defined%0A      # structure and resetting it to zero size.%0A%0A      {Structure_And_IH_Destructive_Structure} is Structure_and_IH_Type%0A%0A      # If the structure has not been cleaned up%2C bail out. There is%0A      # no point continuing.%0A      How_Many_Now = countof {Structure_And_IH_Destructive_Structure}%0A%0A      if How_Many_Now != 0 then%0A         Test_Has_Failed = TRUE%0A         break%0A      endif%0A%0A      breakif Big_Bean_Counter = Number_Of_Iterations%0A%0A      Big_Bean_Counter = Big_Bean_Counter + 1%0A%0A   endloop%0A%0A   if Test_Has_Failed then%0A      [] = RPT3:Test_Failed["Structures not cleared up"%2C Test_Number%2C Big_Bean_Counter]%0A   else%0A      Result_Value = Little_Bean_Counter * Big_Bean_Counter%0A      [] = RPT2:Test_Passed["Structures cleared"%2C Test_Number%2C Result_Value]%0A   endif%0A%0A   Test_Number = Test_Number + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A%0Amy_test.The_Test_Number = Test_Number,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,11,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Structures_are_Cleared%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,private,Test_the_Structure,12,,,
codeblock,# Set up scenario test data.%0ATest_Has_Passed = FALSE%0A%0AMy_Test_Data = find-one Test_Data%0ATest = My_Test_Data.The_Test_Number%0A%0A#--------------------------------------------------------------------------%0A# Test 1%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Returning Structure"%2C "Test returning structure"]%0A%0A   The_New_Int = 100%0A   The_New_Col of Colour_Type = 'Red'%0A%0A   {The_New_Struct} is My_Simple_Structure%0A%0A   append[The_New_Int%2CThe_New_Col] to {The_New_Struct}%0A%0A   [{Returning_Structure}] = Struct5::Test_The_Structure[Test%2C {The_New_Struct}]%0A%0A   for [the_integer%2C the_colour] in {Returning_Structure} do%0A%0A      if the_integer = 200 then%0A%0A         if the_colour = 'Blue' then%0A            [] = RPT2:Test_Passed["Structures"%2C Test%2C 0]%0A         else%0A            [] = RPT3:Test_Failed["Structures"%2C Test%2C -1]%0A         endif%0A%0A      else%0A         [] = RPT3:Test_Failed["Structures"%2C Test%2C -2]%0A      endif%0A%0A   endfor%0A%0A   Test = Test + 1%0A%0A# End Test 1%0A%0A#--------------------------------------------------------------------------%0A# Test 2%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Returning Structure"%2C "Test returning structure"]%0A%0A   The_New_Int = 100%0A   The_New_Real = 1.0%0A   The_New_String = "Structures Test"%0A   The_New_Colour of Colour_Type = 'Blue'%0A%0A   [{The_Returning_Structure}] = Struct10::Check_Returning_Structure[The_New_Int%2C The_New_Real%2C The_New_String%2C The_New_Colour]%0A%0A   for [The_Returned_Int%2C The_Returned_Real%2C The_Returned_String%2C The_Returned_UDT] in {The_Returning_Structure} do%0A%0A      if The_Returned_Int = 200 then%0A%0A         if The_Returned_Real = 2.0 then%0A%0A            if The_Returned_String = "Test Complete" then%0A%0A               if The_Returned_UDT = 'Green' then   %0A                  [] = RPT2:Test_Passed["Structures"%2C Test%2C 0]%0A               else   %0A                  [] = RPT3:Test_Failed["Structures"%2C Test%2C -1]%0A               endif%0A%0A            else%0A              [] = RPT3:Test_Failed["Structures"%2C Test%2C -2]%0A            endif%0A%0A         else%0A            [] = RPT3:Test_Failed["Structures"%2C Test%2C -3]%0A         endif%0A%0A      else%0A         [] = RPT3:Test_Failed["Structures"%2C Test%2C -4]%0A      endif%0A%0A   endfor%0A%0A   Test = Test + 1%0A%0A# End Test 2%0A%0A#--------------------------------------------------------------------------%0A# Test 3%0A#--------------------------------------------------------------------------%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Returning Structure"%2C "Test returning structure"]%0A%0A   The_New_Int = 100%0A   The_New_Col of Colour_Type = 'Red'%0A%0A   {New_Structure} is My_Simple_Structure%0A%0A   append[The_New_Int%2C The_New_Col] to {New_Structure}%0A%0A   %0A   [{New_Structure}] = Struct5::Test_The_Structure[Test%2C {New_Structure}]%0A%0A   How_Many = countof{New_Structure}%0A%0A   if How_Many = 2 then%0A%0A      Count = 1%0A%0A      for [the_integer%2C the_colour] in {New_Structure} do%0A%0A         if the_integer = 200 then%0A%0A            if the_colour = 'Blue' then%0A               [] = RPT2:Test_Passed["Structures"%2C Test%2C 0]%0A            else%0A               [] = RPT3:Test_Failed["Structures"%2C Test%2C -1]%0A           endif%0A%0A         else%0A            Count = Count + 1%0A%0A            if Count = 3 then%0A               [] = RPT3:Test_Failed["Structures"%2C Test%2C -2]%0A            endif%0A%0A         endif%0A%0A      endfor%0A %0A   else%0A      [] = RPT3:Test_Failed["Structures"%2C Test%2C -3]%0A   endif%0A  %0A   Test = Test + 1%0A%0A# End Test 3%0A%0A#--------------------------------------------------------------------------%0A%0AMy_Test_Data.The_Test_Number = Test,,,,,,,
codeblock,,,,,,,,
pragma,scenario,,,,,,,
pragmaitem,12,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Test_the_Structure%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Decode_Simple_Structure,2,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Simple_Structure,in,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Domain synch service"%2C "Decode simple structure"]%0A%0ACount = 1%0A%0A# How many in the set%0A%0AHow_Many = countof{Simple_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean%2C the_colour ] in {Simple_Structure} do%0A%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A   local_colour  = the_colour%0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be up to ten passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A%0A      if local_integer = Object_Instance_Handle.An_Integer and \%0A         local_real    = Object_Instance_Handle.A_Real     and \%0A         local_text    = Object_Instance_Handle.Some_Text  and \%0A         local_boolean = Object_Instance_Handle.A_Boolean  and \%0A         local_colour  = Object_Instance_Handle.A_Colour   then%0A%0A         [] = RPT2:Test_Passed["Structures"%2C Test%2C Count]%0A%0A       else%0A         [] = RPT3:Test_Failed["Structures"%2C Test%2C Count]%0A       endif%0A%0A   endif%0A%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Decode_Simple_TL_Structure,4,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Simple_Structure,in,,,,,,
typeref,Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Domain synch service"%2C "Decode simple TL structure"]%0A%0ACount = 1%0A%0A# How many in the set%0A%0AHow_Many = countof{Simple_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean] in {Simple_Structure} do%0A%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be up to ten passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A%0A      if local_integer = Object_Instance_Handle.An_Integer and \%0A         local_real    = Object_Instance_Handle.A_Real     and \%0A         local_text    = Object_Instance_Handle.Some_Text  and \%0A         local_boolean = Object_Instance_Handle.A_Boolean  then%0A%0A         [] = RPT2:Test_Passed["Structures"%2C Test%2C Count]%0A%0A       else%0A         [] = RPT3:Test_Failed["Structures"%2C Test%2C Count]%0A       endif%0A%0A   endif%0A%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Decode_Simple_NTL_Structure,6,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Simple_Structure,in,,,,,,
typeref,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Domain synch service"%2C "Decode simple structure"]%0A%0ACount = 1%0A%0A# How many in the set%0A%0AHow_Many = countof{Simple_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean] in {Simple_Structure} do%0A%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be up to ten passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A%0A      if local_integer = Object_Instance_Handle.An_Integer and \%0A         local_real    = Object_Instance_Handle.A_Real     and \%0A         local_text    = Object_Instance_Handle.Some_Text  and \%0A         local_boolean = Object_Instance_Handle.A_Boolean  then%0A%0A         [] = RPT2:Test_Passed["Structures"%2C Test%2C Count]%0A%0A       else%0A         [] = RPT3:Test_Failed["Structures"%2C Test%2C Count]%0A       endif%0A%0A   endif%0A%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0A%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Decode_Three_Level_Nested_Structure,7,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Three_Level_Nest,in,,,,,,
typeref,First_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Two_Level_Nest,in,,,,,,
typeref,Second_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,One_Level_Nest,in,,,,,,
typeref,Third_Nested_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Given_First_Level_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,How_Many_In_First,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Given_Second_Level_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,How_Many_In_Second,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Given_Third_Level_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,How_Many_In_Third,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Given_Third_Level_Colour,in,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,%0A[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Nested structures"%2C "Three levels of nest"]%0A%0ATest_Has_Passed   = FALSE%0AOK_To_Proceed = FALSE%0AFailure_Code  = 0%0A%0AHow_Many = countof{One_Level_Nest}%0A%0A# First compare the contents of the parameter One_Level_Nest to known datum%0A%0Afor [number%2C colour] in {One_Level_Nest} do%0A%0A   if colour   = Given_Third_Level_Colour &\%0A      number   = Given_Third_Level_Number &\%0A      How_Many = How_Many_In_Third  then%0A      %0A      # The datum and the simple non-nested structure match%0A      OK_To_Proceed = TRUE%0A%0A   else%0A      OK_To_Proceed = FALSE%0A      Failure_Code  = -1%0A   endif%0A%0Aendfor%0A%0A# Simple structure matches the given data%2C precautionary check.%0Aif OK_To_Proceed then%0A%0A   #Since no equivalence check for structures exists in WACA%2C let's ... off road%0A%0A   # Bear in mind that One_Level_Nest has now been destructively read and%0A   # no longer exists. %0A%0A   # Decode the whole nine yards.%0A%0A   # Relying on the calling routine to specify the full structure and also%0A   # provide all the count information means that each non-structure entry %0A   # in a set must contain the same data as the previous structure.%0A%0A   How_Many_First = countof{Three_Level_Nest}%0A%0A   if How_Many_First = How_Many_In_First then%0A%0A      # Read from top level set%0A      for [{Second_Level}%2C First_Level_Number ] in {Three_Level_Nest} do%0A%0A         How_Many_Second = countof{Second_Level}%0A%0A         if First_Level_Number = Given_First_Level_Number &\%0A            How_Many_Second    = How_Many_In_Second then%0A%0A            # Read from second level intermediary set%0A            for [{Third_Level}%2C Second_Level_Number] in {Second_Level} do%0A%0A               How_Many_Third = countof{Third_Level}%0A%0A               if Second_Level_Number = Given_Second_Level_Number &\%0A                  How_Many_Third      = How_Many_In_Third then%0A%0A                  # Read from bottom level third set%0A                  for [Third_Level_Number%2C Third_Level_Colour] in {Third_Level} do%0A%0A                     if Third_Level_Number = Given_Third_Level_Number &\%0A                        Third_Level_Colour = Given_Third_Level_Colour then%0A%0A                        Test_Has_Passed  = TRUE%0A                        Failure_Code = 0%0A  %0A                     else%0A                        Test_Has_Passed = FALSE%0A                        Failure_Has_Code = -5%0A                     endif%0A%0A                  endfor%0A%0A               else%0A                  Test_Has_Passed = FALSE%0A                  Failure_Code = -4%0A               endif%0A%0A            endfor%0A%0A         else%0A            Test_Has_Passed = FALSE%0A            Failure_Code = -3%0A         endif%0A%0A      endfor%0A%0A   else%0A      Failure_Code = -2%0A      Test_Has_Passed = FALSE%0A   endif%0A%0Aendif%0A%0A%0Aif Test_Has_Passed then%0A   [] = RPT2:Test_Passed["Three levels of nest"%2C Test%2C 0]%0Aelse%0A   [] = RPT3:Test_Failed["Three levels of nest"%2C Test%2C Failure_Code]%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Create_Report_Data,8,,,
codeblock,# Find out of there already is one of these.%0A# It is not inconceivable that a report object still exists from a previous run.%0A# Report objects are not deleted at the end of a run%2C as certain events may%0A# still be en-queued.%0A%0Aold_report = find-one Report_Data%0A%0Aif old_report != UNDEFINED then%0A   delete old_report%0Aendif%0A%0AMy_Report = create unique Report_Data with Reported_Domain_Number = 0%0A%0A[] = RPT6:Domain_Test_Start["Structures"]%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Delete_Report_Data,9,,,
codeblock,[] = RPT7:Domain_Test_Finished["Structures"]%0A%0A# Do not delete the Report_Data object%2C as there may be still events in%0A# the queue.,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Receive_Structure_IH,1,,,
parameter,This_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Input_Structure,in,,,,,,
typeref,Structure_and_IH_Type,,,,,,,
typeref,,,,,,,,
parameter,Number_Of_Elements,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Unique_Identifier_Of_IH,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[This_Test_Number%2C"1241-0000-01-1216"%2C "Structures"%2C "Structure and IH"%2C Testing_For]%0A[] = RPT8:Specify_Requid[This_Test_Number%2C "1101-0000-01-0140"]%0A%0AHow_Many_In_Structure = countof {Input_Structure}%0A%0Aif How_Many_In_Structure = Number_Of_Elements then%0A%0A   # We got as many as we were expecting. Now look and see that the latest%0A   # one in the structure has the same unique attribute as the parameter.%0A%0A   # NB This would be real easy if 'find' operations where supported for sets%2C%0A   #    but%2C tough luck%2C they aren't.%0A%0A   Result_Found = FALSE%0A   Bean_Counter = 0%0A   for [Dereferenced_IH] in {Input_Structure} do%0A%0A      if Dereferenced_IH != UNDEFINED then%0A         Bean_Counter = Bean_Counter + 1%0A      endif%0A%0A      # Found the one we are interested in. Should be the final element in the structure.%0A      if Bean_Counter = Number_Of_Elements then%0A%0A         if Dereferenced_IH.Reference_SO = Unique_Identifier_Of_IH then%0A            Result_Found = TRUE%0A         endif%0A%0A         # Bail out of the loop. %0A         break%0A %0A      endif%0A%0A   endfor%0A%0A   if Result_Found then%0A      [] = RPT2:Test_Passed[Testing_For%2C This_Test_Number%2C Unique_Identifier_Of_IH]%0A   else%0A      [] = RPT3:Test_Failed["Unmatched IH identifier "%2C This_Test_Number%2C Unique_Identifier_Of_IH]%0A   endif%0A%0Aelse%0A %0A   [] = RPT3:Test_Failed["Inconsistent number of elements"%2C This_Test_Number%2C How_Many_In_Structure]%0A%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
description, Receive a structure containing and IH as a component of that structure.%0A,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Receive_Empty_Structure_IH,3,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Empty_Structure,in,,,,,,
typeref,Structure_and_IH_Type,,,,,,,
typeref,,,,,,,,
parameter,Inserted_IH,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Testing_For,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Filled_Structure,out,,,,,,
typeref,Structure_and_IH_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test_Number%2C "1241-0000-01-1216"%2C "Structures"%2C "Receive Empty Structure"%2C Testing_For]%0A%0AHow_Many_In_Structure = countof{Empty_Structure}%0A%0ABean_Counter = 0%0A%0Afor [An_IH] in {Empty_Structure} do%0A%0A   Bean_Counter = Bean_Counter + 1%0A%0Aendfor%0A%0Aif Bean_Counter = 0 & \%0A   How_Many_In_Structure = 0 then%0A%0A   Structure_Is_Empty = TRUE%0A%0Aelse%0A%0A   Structure_Is_Empty = FALSE%0A%0Aendif%0A%0Aif Inserted_IH != UNDEFINED then%0A%0A   append [Inserted_IH] to {Filled_Structure}%0A%0A   if Structure_Is_Empty then%0A%0A      [] = RPT2:Test_Passed[Testing_For%2C Test_Number%2C Bean_Counter]%0A%0A   else%0A%0A      [] = RPT3:Test_Failed["Structure was not empty"%2C Test_Number%2C Bean_Counter]%0A%0A   endif%0A%0Aelse%0A%0A   [] = RPT3:Test_Failed["IH does not exist"%2C Test_Number%2C -1]%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Test_The_Structure,5,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Structure_Input,in,,,,,,
typeref,My_Simple_Structure,,,,,,,
typeref,,,,,,,,
parameter,The_Return_Structure,out,,,,,,
typeref,My_Simple_Structure,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,for [the_integer%2C the_color] in {Structure_Input} do%0A%0A   local_integer = the_integer%0A   local_color  = the_color%0A%0A   if local_color = 'Red' then%0A      local_integer = 200%0A      local_color   of Colour_Type = 'Blue'%0A   endif   %0A%0Aendfor%0A%0Aappend [local_integer%2C local_color] to {The_Return_Structure}%0A,,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Check_Returning_Structure,10,,,
parameter,Integer_Input,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Real_Input,in,,,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
parameter,String_Input,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,UDT_Input,in,,,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
parameter,Returning_Structure,out,,,,,,
typeref,My_Second_Structure,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,%0Aif Integer_Input = 100 then%0A   Local_Integer = 200 %0Aendif%0A%0Aif Real_Input = 1.0 then%0A   Local_Real = 2.0%0Aendif%0A%0Aif String_Input = "Structures Test" then%0A  Local_String = "Test Complete"%0Aendif%0A%0Aif UDT_Input = 'Blue' then%0A   Local_UDT of Colour_Type = 'Green'%0Aendif%0A%0Aappend [Local_Integer%2C Local_Real%2C Local_String%2C Local_UDT] to {Returning_Structure},,,,,,,
codeblock,,,,,,,,
routine,,,,,,,,
terminator,Report,RPT,,,,,,
routine,Struct,,public,Start_Test,1,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Requid,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Invoking_Domain,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Invoking_Object,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Purpose,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Test_Passed,2,,,
parameter,Test_Object_Domain,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Test_Value,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Test_Failed,3,,,
parameter,Failed_Domain_Object,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,Failed_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Failed_Test_Value,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Test_Unsupported,4,,,
parameter,Unsupported_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Test_Text,5,,,
parameter,Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Free_Text,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Domain_Test_Start,6,,,
parameter,This_Domain_Name,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Domain_Test_Finished,7,,,
parameter,This_Domain_Name,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Specify_Requid,8,,,
parameter,Requid_Test_Number,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,The_Requid_Itself,in,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
terminator,,,,,,,,
terminator,Env_Terminator,ET,,,,,,
routine,Struct,,public,Env_String,1,,,
parameter,Env_Text,out,,,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
routine,Struct,,public,Env_Number,2,,,
parameter,Env_Integer,out,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
routine,,,,,,,,
terminator,,,,,,,,
object,Report_Data,RD,3,,,,,
attribute,Report_Data_Unique_id,preferred,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Reported_Domain_Number,,,Report_Data_Unique_id,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
object,Structured_Object,SO,2,,,,,
attribute,Reference_SO,preferred,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,An_Integer,,,Reference_SO,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,A_Real,,,An_Integer,,,,
typeref,real,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,Some_Text,,,A_Real,,,,
typeref,string,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,A_Boolean,,,Some_Text,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
attribute,A_Colour,,,A_Boolean,,,,
typeref,Colour_Type,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
operation,Struct,Structured_Object,public,Create_Simple_Structure,,,1,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Returned_Simple_Structure,out,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C"1241-0000-01-1212"%2C "Structures"%2C "objSO"%2C "Construct simple structure"]%0A%0AHow_Many = countof {Returned_Simple_Structure}%0A%0Aloop_counter = How_Many + 1%0A%0AFailure_Value = 0%0A%0ATermination_Condition = loop_counter + 5%0A%0A# Add five elements into the set%0A%0Aloop%0A%0A   # This is supposed to be a set%2C therefore%2C stuff several%0A   # version of the input data into it.%0A   # This will be determined by the test number at the time.%0A   append [Object_Instance_Handle.An_Integer%2C \%0A           Object_Instance_Handle.A_Real%2C   \%0A           Object_Instance_Handle.Some_Text%2C \ %0A           Object_Instance_Handle.A_Boolean%2C \%0A           Object_Instance_Handle.A_Colour]   \%0A   to {Returned_Simple_Structure}%0A%0A   loop_counter = loop_counter + 1%0A%0A   breakif loop_counter = Termination_Condition%0A%0Aendloop%0A%0AHow_Many_Now = countof {Returned_Simple_Structure}   %0A%0A%0A# All tests%0A%0A %0A[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text%2C Test%2C How_Many_Now]%0A%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Decode_Simple_Structure,,,2,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Structure,in,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Final_Entry_Only,in,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock, %0A[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Structured Object Synch Service"%2C "Decode simple data structures"]%0A%0A# How many in the set%0AHow_Many = countof {A_Structure}%0A%0ACount = 1%0A%0A# Look at the final entry in the list only.%0Aif Final_Entry_Only = TRUE then%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean%2C the_colour] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A      local_colour  = the_colour%0A%0A      # Force a look at the penultimate entry in the set.%0A      Termination_Condition = How_Many - 1%0A%0A      # Only look at the final entry%0A      if Count = Termination_Condition then %0A%0A         if local_integer = Instance_Handle.An_Integer and \%0A            local_real    = Instance_Handle.A_Real     and \%0A            local_text    = Instance_Handle.Some_Text  and \%0A            local_boolean = Instance_Handle.A_Boolean  and \%0A            local_colour  = Instance_Handle.A_Colour   then%0A%0A            [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         else%0A  %0A            [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         endif%0A%0A      endif%0A%0A      Count = Count + 1%0A%0A      # Don't want to read all the entries%2C just all but one of them.%0A      # This so that we can append into the set again on the next iteration.%0A%0A      breakif Count = How_Many%0A%0A   endfor%0A%0A# Look at all entries%0Aelse%0A%0A   Has_Passed = TRUE%0A   Passed_Count = 0%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean%2C the_colour] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A      local_colour  = the_colour%0A%0A      if local_integer = Instance_Handle.An_Integer and \%0A         local_real    = Instance_Handle.A_Real     and \%0A         local_text    = Instance_Handle.Some_Text  and \%0A         local_boolean = Instance_Handle.A_Boolean  and \%0A         local_colour  = Instance_Handle.A_Colour   then%0A%0A         Passed_Count = Passed_Count + 1%0A%0A      else%0A%0A         Has_Passed = FALSE%0A         Passed_Count = Passed_Count - 1%0A  %0A       endif%0A%0A      Count = Count + 1%0A%0A   endfor%0A%0A   if Has_Passed = TRUE then%0A%0A      [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   else%0A%0A      [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   endif%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Create_Complex_Structure,,,3,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Decode_Complex_Structure,,,4,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Create_Simple_TL_Structure,,,5,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Returned_Simple_Structure,out,,,,,,
typeref,Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C"1241-0000-01-1212"%2C "Structures"%2C "objSO"%2C "Construct Type Linked simple structure"]%0A%0AHow_Many = countof {Returned_Simple_Structure}%0A%0Aloop_counter = How_Many + 1%0A%0AFailure_Value = 0%0A%0ATermination_Condition = loop_counter + 5%0A%0A# Add five elements into the set%0A%0Aloop%0A%0A   # This is supposed to be a set%2C therefore%2C stuff several%0A   # version of the input data into it.%0A   # This will be determined by the test number at the time.%0A   append [Object_Instance_Handle.An_Integer%2C \%0A           Object_Instance_Handle.A_Real%2C   \%0A           Object_Instance_Handle.Some_Text%2C \ %0A           Object_Instance_Handle.A_Boolean]   \%0A   to {Returned_Simple_Structure}%0A%0A   loop_counter = loop_counter + 1%0A%0A   breakif loop_counter = Termination_Condition%0A%0Aendloop%0A%0AHow_Many_Now = countof {Returned_Simple_Structure}   %0A%0A%0A# All tests%0A   %0A[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text%2C Test%2C How_Many_Now]%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Decode_Simple_TL_Structure,,,6,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Structure,in,,,,,,
typeref,Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Final_Entry_Only,in,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock, %0A[] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Structured Object Synch Service"%2C "Decode simple TL data structures"]%0A%0A# How many in the set%0AHow_Many = countof {A_Structure}%0A%0ACount = 1%0A%0A# Look at the final entry in the list only.%0Aif Final_Entry_Only = TRUE then%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A%0A      # Force a look at the penultimate entry in the set.%0A      Termination_Condition = How_Many - 1%0A%0A      # Only look at the final entry%0A      if Count = Termination_Condition then %0A%0A         if local_integer = Instance_Handle.An_Integer and \%0A            local_real    = Instance_Handle.A_Real     and \%0A            local_text    = Instance_Handle.Some_Text  and \%0A            local_boolean = Instance_Handle.A_Boolean  then%0A%0A            [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         else%0A  %0A            [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         endif%0A%0A      endif%0A%0A      Count = Count + 1%0A%0A      # Don't want to read all the entries%2C just all but one of them.%0A      # This so that we can append into the set again on the next iteration.%0A%0A      breakif Count = How_Many%0A%0A   endfor%0A%0A# Look at all entries%0Aelse%0A%0A   Passed_Count = 0%0A%0A   Local_Test_Passed = TRUE%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A%0A      if local_integer = Instance_Handle.An_Integer and \%0A         local_real    = Instance_Handle.A_Real     and \%0A         local_text    = Instance_Handle.Some_Text  and \%0A         local_boolean = Instance_Handle.A_Boolean  then%0A%0A         Passed_Count = Passed_Count + 1%0A%0A      else%0A%0A         Passed_Count = Passed_Count - 1%0A         Local_Test_Passed = FALSE %0A %0A       endif%0A%0A      Count = Count + 1%0A%0A   endfor%0A%0A   if Local_Test_Passed = TRUE then%0A%0A      [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   else%0A%0A      [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   endif%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Create_Simple_NTL_Structure,,,7,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,Object_Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Returned_Simple_Structure,out,,,,,,
typeref,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C"1241-0000-01-1212"%2C "Structures"%2C "objSO"%2C "Construct simple NTL structure"]%0A%0AHow_Many = countof {Returned_Simple_Structure}%0A%0Aloop_counter = How_Many + 1%0A%0AFailure_Value = 0%0A%0ATermination_Condition = loop_counter + 5%0A%0A# Add five elements into the set%0A%0Aloop%0A%0A   # This is supposed to be a set%2C therefore%2C stuff several%0A   # version of the input data into it.%0A   # This will be determined by the test number at the time.%0A   append [Object_Instance_Handle.An_Integer%2C \%0A           Object_Instance_Handle.A_Real%2C   \%0A           Object_Instance_Handle.Some_Text%2C \ %0A           Object_Instance_Handle.A_Boolean]   \%0A   to {Returned_Simple_Structure}%0A%0A   loop_counter = loop_counter + 1%0A%0A   breakif loop_counter = Termination_Condition%0A%0Aendloop%0A%0AHow_Many_Now = countof {Returned_Simple_Structure}   %0A%0A%0A# All tests%0A   %0A[] = RPT2:Test_Passed[Object_Instance_Handle.Some_Text%2C Test%2C How_Many_Now]%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
operation,Struct,Structured_Object,public,Decode_Simple_NTL_Structure,,,8,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Structure,in,,,,,,
typeref,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,Instance_Handle,in,,,,,,
typeref,instance of Structured_Object,,,,,,,
typeref,,,,,,,,
parameter,Final_Entry_Only,in,,,,,,
typeref,boolean,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock, %0A%0A# How many in the set%0AHow_Many = countof {A_Structure}%0A%0ACount = 1%0A%0A# Look at the final entry in the list only.%0Aif Final_Entry_Only = TRUE then%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Structured Object Synch Service"%2C "Decode simple final NTL data structure"]%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A%0A      # Force a look at the penultimate entry in the set.%0A      Termination_Condition = How_Many - 1%0A%0A      # Only look at the final entry%0A      if Count = Termination_Condition then %0A%0A         if local_integer = Instance_Handle.An_Integer and \%0A            local_real    = Instance_Handle.A_Real     and \%0A            local_text    = Instance_Handle.Some_Text  and \%0A            local_boolean = Instance_Handle.A_Boolean  then%0A%0A            [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         else%0A  %0A            [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Count]%0A%0A         endif%0A%0A      endif%0A%0A      Count = Count + 1%0A%0A      # Don't want to read all the entries%2C just all but one of them.%0A      # This so that we can append into the set again on the next iteration.%0A%0A      breakif Count = How_Many%0A%0A   endfor%0A%0A# Look at all entries%0Aelse%0A%0A   [] = RPT1:Start_Test[Test%2C "1241-0000-01-1212"%2C "Structures"%2C "Structured Object Synch Service"%2C "Decode simple all NTL data structures"]%0A%0A   Has_Passed = TRUE%0A   Passed_Count = 0%0A%0A%0A   for [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_Structure} do%0A%0A      local_integer = the_integer%0A      local_real    = the_real%0A      local_text    = the_text%0A      local_boolean = the_boolean%0A%0A      if local_integer = Instance_Handle.An_Integer and \%0A         local_real    = Instance_Handle.A_Real     and \%0A         local_text    = Instance_Handle.Some_Text  and \%0A         local_boolean = Instance_Handle.A_Boolean  then%0A%0A         Passed_Count = Passed_Count + 1%0A%0A      else%0A%0A         Has_Passed   = FALSE%0A         Passed_Count = Passed_Count - 1%0A%0A  %0A       endif%0A%0A      Count = Count + 1%0A%0A   endfor%0A%0A   if Has_Passed = TRUE then%0A%0A      [] = RPT2:Test_Passed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   else%0A%0A      [] = RPT3:Test_Failed[Instance_Handle.Some_Text%2C Test%2C Passed_Count]%0A%0A   endif%0A%0A%0Aendif%0A,,,,,,,
codeblock,,,,,,,,
operation,,,,,,,,
state,,Structured_Object,Idle,,1,,,
state,,,,,,,,
state,,Structured_Object,Decode_Simple,,2,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Simple_Structure,in,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "Structures"%2C "Structured_Object"%2C "generate simple decode"]%0A%0ACount = 1%0AHas_Failed = FALSE%0A%0A# How many in the set%0A%0AHow_Many = countof {A_Simple_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean%2C the_colour] in {A_Simple_Structure} do%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A   local_colour  = the_colour %0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be numerous passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A      if local_integer = this.An_Integer and \%0A         local_real    = this.A_Real and \%0A         local_text    = this.Some_Text and \%0A         local_boolean = this.A_Boolean and \%0A         local_colour  = this.A_Colour then%0A%0A         [] = RPT2:Test_Passed[this.Some_Text%2C Test%2C this.An_Integer]%0A       else%0A         [] = RPT3:Test_Failed[this.Some_Text%2C Test%2C this.An_Integer]%0A         Has_Failed = TRUE%0A%0A       endif%0A%0A   endif%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0A%0Aif Has_Failed then%0A   generate SO4:Fault() to this%0Aelse%0A   generate SO3:Finished() to this%0Aendif%0A%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,Structured_Object,Decode_Complex,,3,,,
state,,,,,,,,
state,,Structured_Object,Failed,,4,,,
state,,,,,,,,
state,,Structured_Object,Decode_Simple_TL,,5,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_TL_Structure,in,,,,,,
typeref,Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "Structures"%2C "Structured_Object"%2C "generate simple TL decode"]%0A%0ACount = 1%0AHas_Failed = FALSE%0A%0A# How many in the set%0A%0AHow_Many = countof {A_TL_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_TL_Structure} do%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be numerous passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A      if local_integer = this.An_Integer and \%0A         local_real    = this.A_Real and \%0A         local_text    = this.Some_Text and \%0A         local_boolean = this.A_Boolean then%0A%0A         [] = RPT2:Test_Passed[this.Some_Text%2C Test%2C this.An_Integer]%0A       else%0A         [] = RPT3:Test_Failed[this.Some_Text%2C Test%2C this.An_Integer]%0A         Has_Failed = TRUE%0A%0A       endif%0A%0A   endif%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0Aif Has_Failed then%0A   generate SO4:Fault() to this%0Aelse%0A   generate SO3:Finished() to this%0Aendif%0A%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,Structured_Object,Decode_Simple_NTL,,6,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_NTL_Structure,in,,,,,,
typeref,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
codeblock,[] = RPT1:Start_Test[Test%2C "Null Requid"%2C "Structures"%2C "Structured_Object"%2C "generate simple NTL decode"]%0A%0ACount = 1%0AHas_Failed = FALSE%0A%0A# How many in the set%0A%0AHow_Many = countof {A_NTL_Structure}%0A%0Afor [the_integer%2C the_real%2C the_text%2C the_boolean] in {A_NTL_Structure} do%0A%0A   local_integer = the_integer%0A   local_real    = the_real%0A   local_text    = the_text%0A   local_boolean = the_boolean%0A%0A   # We are only interested in the final value in the set%2C otherwise%0A   # there would be numerous passes shown in the results file%0A   # for this test.%0A%0A   if Count = How_Many then%0A%0A      # This is the position in the set that we are interested in%0A      if local_integer = this.An_Integer and \%0A         local_real    = this.A_Real and \%0A         local_text    = this.Some_Text and \%0A         local_boolean = this.A_Boolean then%0A%0A         [] = RPT2:Test_Passed[this.Some_Text%2C Test%2C this.An_Integer]%0A       else%0A         [] = RPT3:Test_Failed[this.Some_Text%2C Test%2C this.An_Integer]%0A         Has_Failed = TRUE%0A%0A       endif%0A%0A   endif%0A%0A   Count = Count + 1%0A%0Aendfor%0A%0A%0Aif Test = 41 then %0A%0A   [] = Struct9::Delete_Report_Data[]%0A%0Aendif%0A%0Aif Has_Failed then%0A   generate SO4:Fault() to this%0Aelse%0A   generate SO3:Finished() to this%0Aendif%0A%0A,,,,,,,
codeblock,,,,,,,,
state,,,,,,,,
state,,Structured_Object,Finished,,8,,,
state,,,,,,,,
event,Start_Simple,,1,,,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_Simple_Structure,in,,,,,,
typeref,Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
event,Start_Complex,,2,,,,,
event,,,,,,,,
event,Finished,,3,,,,,
event,,,,,,,,
event,Fault,,4,,,,,
event,,,,,,,,
event,Start_TL_Simple,,5,,,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_TL_Structure,in,,,,,,
typeref,Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
event,Start_NTL_Simple,,6,,,,,
parameter,Test,in,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
parameter,A_NTL_Structure,in,,,,,,
typeref,Name_and_Type_Linked_Simple_Structure_Type,,,,,,,
typeref,,,,,,,,
parameter,,,,,,,,
parameter,,,,,,,,
event,,,,,,,,
transitiontable,,,,,,,,
transition,Non_Existent,,,Start_Simple,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Start_Complex,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Finished,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Fault,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Start_TL_Simple,Cannot_Happen,,,
transition,,,,,,,,
transition,Non_Existent,,,Start_NTL_Simple,Cannot_Happen,,,
transition,,,,,,,,
transition,Idle,,,Start_Simple,Decode_Simple,,,
transition,,,,,,,,
transition,Idle,,,Start_Complex,Decode_Complex,,,
transition,,,,,,,,
transition,Idle,,,Finished,Ignore,,,
transition,,,,,,,,
transition,Idle,,,Fault,Ignore,,,
transition,,,,,,,,
transition,Idle,,,Start_TL_Simple,Decode_Simple_TL,,,
transition,,,,,,,,
transition,Idle,,,Start_NTL_Simple,Decode_Simple_NTL,,,
transition,,,,,,,,
transition,Decode_Simple,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple,,,Finished,Finished,,,
transition,,,,,,,,
transition,Decode_Simple,,,Fault,Failed,,,
transition,,,,,,,,
transition,Decode_Simple,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Complex,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Complex,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Decode_Complex,,,Finished,Finished,,,
transition,,,,,,,,
transition,Decode_Complex,,,Fault,Failed,,,
transition,,,,,,,,
transition,Decode_Complex,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Complex,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Finished,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Fault,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Failed,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Finished,Finished,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Fault,Failed,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_TL,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Finished,Finished,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Fault,Failed,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Decode_Simple_NTL,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Start_Simple,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Start_Complex,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Finished,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Fault,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Start_TL_Simple,Ignore,,,
transition,,,,,,,,
transition,Finished,,,Start_NTL_Simple,Ignore,,,
transition,,,,,,,,
transitiontable,,,,,,,,
object,,,,,,,,
object,Test_Data,TD,4,,,,,
attribute,The_Test_Number,,,,,,,
typeref,integer,,,,,,,
typeref,,,,,,,,
attribute,,,,,,,,
object,,,,,,,,
pragma,version,,,,,,,
pragmaitem,6,,,,,,,
pragmaitem,,,,,,,,
pragma,,,,,,,,
description, Mission statement? %0A You're having a laugh!%0A,,,,,,,
domain,,,,,,,,
